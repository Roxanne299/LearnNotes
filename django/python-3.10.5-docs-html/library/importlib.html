
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>importlib --- import 的实现 &#8212; Python 3.10.5 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.10.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="使用 importlib.metadata" href="importlib.metadata.html" />
    <link rel="prev" title="runpy ——查找并执行 Python 模块" href="runpy.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/importlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> —— 关于导入的抽象基类</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> -- 资源</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> —— 导入器和路径钩子函数。</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> —— 导入器的工具程序代码</a></li>
<li><a class="reference internal" href="#examples">例子</a><ul>
<li><a class="reference internal" href="#importing-programmatically">用编程方式导入</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">检查某模块可否导入。</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">直接导入源码文件。</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">实现延迟导入</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">导入器的配置</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> 的近似实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="runpy.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> ——查找并执行 Python  模块</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="下一章">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/importlib.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="使用 importlib.metadata"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy ——查找并执行 Python 模块"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">导入模块</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现<a class="headerlink" href="#module-importlib" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.1 新版功能.</span></p>
</div>
<p><strong>源代码</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<section id="introduction">
<h2>概述<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 包的目的有两个。 第一个目的是在 Python 源代码中提供 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的实现（并且因此而扩展 <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数）。 这提供了一个可移植到任何 Python 解释器的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 实现。 相比使用 Python 以外的编程语言实现方式，这一实现更加易于理解。</p>
<p>第二个目的是实现 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 的部分被公开在这个包中，使得用户更容易创建他们自己的自定义对象 (通常被称为 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>) 来参与到导入过程中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">import 语句</span></a></dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句的语言参考</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">包规格说明</a></dt><dd><p>包的初始规范。自从编写这个文档开始，一些语义已经发生改变了（比如基于 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的重定向）。</p>
</dd>
<dt><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数</dt><dd><p><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句是这个函数的语法糖。</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt><dd><p>在忽略大小写的平台上进行导入</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt><dd><p>定义 Python 源代码编码</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt><dd><p>新导入钩子</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt><dd><p>导入：多行和绝对/相对</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt><dd><p>主模块显式相对导入</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></dt><dd><p>隐式命名空间包</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt><dd><p>导入系统的一个模块规范类型</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></dt><dd><p>消除PYO文件</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></dt><dd><p>多阶段扩展模块初始化</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0552"><strong>PEP 552</strong></a></dt><dd><p>确定性的 pyc 文件</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt><dd><p>使用 UTF-8 作为默认的源编码</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt><dd><p>PYC 仓库目录</p>
</dd>
</dl>
</div>
</section>
<section id="functions">
<h2>函数<a class="headerlink" href="#functions" title="永久链接至标题">¶</a></h2>
<dl class="py function">
<dt id="importlib.__import__">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">__import__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">globals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">locals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fromlist</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="永久链接至目标">¶</a></dt>
<dd><p>内置 <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数的实现。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>程序式地导入模块应该使用 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 而不是这个函数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.import_module">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="永久链接至目标">¶</a></dt>
<dd><p>导入一个模块。参数 <em>name</em> 指定了以绝对或相对导入方式导入什么模块 (比如要么像这样 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> 或者这样 <code class="docutils literal notranslate"><span class="pre">..mod</span></code>)。如果参数 name 使用相对导入的方式来指定，那么那个参数 <em>packages</em> 必须设置为那个包名，这个包名作为解析这个包名的锚点 (比如  <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> 将会导入 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)。</p>
<p><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 函数是一个对 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a> 进行简化的包装器。 这意味着该函数的所有主义都来自于 <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>。 这两个函数之间最重要的不同点在于 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 返回指定的包或模块 (例如 <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>)，而 <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 返回最高层级的包或模块 (例如 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>)。</p>
<p>如果动态导入一个自从解释器开始执行以来被创建的模块（即创建了一个 Python 源代码文件），为了让导入系统知道这个新模块，可能需要调用 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>父包会被自动导入。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.find_loader">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>查找一个模块的加载器，可选择地在指定的 <em>path</em> 里面。如果这个模块是在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>，那么返回 <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__loader__</span></code> (除非这个加载器是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或者是没有被设置， 在这样的情况下，会引起 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常）。 否则使用 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 的一次搜索就结束。如果未发现加载器，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>点状的名称没有使得它父包或模块隐式地导入，因为它需要加载它们并且可能不需要。为了适当地导入一个子模块，需要导入子模块的所有父包并且使用正确的参数提供给 <em>path</em>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果没有设置 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>，会引起 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常，就像属性设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的时候一样。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.invalidate_caches">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>使查找器存储在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 中的内部缓存无效。如果一个查找器实现了 <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code>，那么它会被调用来执行那个无效过程。 如果创建/安装任何模块，同时正在运行的程序是为了保证所有的查找器知道新模块的存在，那么应该调用这个函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.reload">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">reload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="永久链接至目标">¶</a></dt>
<dd><p>重新加载之前导入的 <em>module</em>。 那个参数必须是一个模块对象，所以它之前必须已经成功导入了。 这在你已经使用外部编辑器编辑过了那个模块的源代码文件并且想在退出 Python 解释器之前试验这个新版本的模块的时候将很适用。 函数的返回值是那个模块对象（如果重新导入导致一个不同的对象放置在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，那么那个模块对象是有可能会不同）。</p>
<p>当执行 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> 的时候：</p>
<ul class="simple">
<li><p>Python 模块的代码会被重新编译并且那个模块级的代码被重新执行，通过重新使用一开始加载那个模块的 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>，定义一个新的绑定在那个模块字典中的名称的对象集合。扩展模块的``init``函数不会被调用第二次。</p></li>
<li><p>与Python中的所有的其它对象一样，旧的对象只有在它们的引用计数为0之后才会被回收。</p></li>
<li><p>模块命名空间中的名称重新指向任何新的或更改后的对象。</p></li>
<li><p>其他旧对象的引用（例如那个模块的外部名称）不会被重新绑定到引用的新对象的，并且如果有需要，必须在出现的每个命名空间中进行更新。</p></li>
</ul>
<p>有一些其他注意事项：</p>
<p>当一个模块被重新加载的时候，它的字典（包含了那个模块的全区变量）会被保留。名称的重新定义会覆盖旧的定义，所以通常来说这不是问题。如果一个新模块没有定义在旧版本模块中定义的名称，则将保留旧版本中的定义。这一特性可用于作为那个模块的优点，如果它维护一个全局表或者对象的缓存 —— 使用 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句，就可以测试表的存在并且跳过它的初始化，如果有需要的话:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>重新加载内置的或者动态加载模块，通常来说不是很有用处。不推荐重新加载&quot;<a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>，<a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>，<a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 和其它关键模块。在很多例子中，扩展模块并不是设计为不止一次的初始化，并且当重新加载时，可能会以任意方式失败。</p>
<p>如果一个模块使用 <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> ... <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ... 导入的对象来自另外一个模块，给其它模块调用 <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> 不会重新定义来自这个模块的对象 —— 解决这个问题的一种方式是重新执行 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> 语句，另一种方式是使用 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 和限定名称(<em>module.name</em>)来代替。</p>
<p>如果一个模块创建一个类的实例，重新加载定义那个类的模块不影响那些实例的方法定义———它们继续使用旧类中的定义。对于子类来说同样是正确的。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>如果重新加载的模块缺少  <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> ，则会触发 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 。</p>
</div>
</dd></dl>

</section>
<section id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> —— 关于导入的抽象基类<a class="headerlink" href="#module-importlib.abc" title="永久链接至标题">¶</a></h2>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p>The <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> module contains all of the core abstract base classes
used by <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>. Some subclasses of the core abstract base classes
are also provided to help in implementing the core ABCs.</p>
<p>ABC 类的层次结构：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="py class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="永久链接至目标">¶</a></dt>
<dd><p>代表 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> 的一个抽象基类</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> 或 <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a> 来代替。</p>
</div>
<dl class="py method">
<dt id="importlib.abc.Finder.find_module">
<em class="property">abstractmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>为指定的模块查找 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 定义的抽象方法。本来是在 <span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 指定的，这个方法是在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 和基于路径的导入子系统中使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当被调用的时候，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.10 版后已移除: </span>改为实现 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaPathFinder.find_spec()</span></code></a> 或 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PathEntryFinder.find_spec()</span></code></a> 。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="永久链接至目标">¶</a></dt>
<dd><p>An abstract base class representing a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>不再是 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a> 的子类。</p>
</div>
<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>一个抽象方法，用于查找指定模块的 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> 。若是顶层导入，<em>path</em> 将为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 否则就是查找子包或模块，<em>path</em> 将是父级包的 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 值。找不到则会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。传入的 <code class="docutils literal notranslate"><span class="pre">target</span></code> 是一个模块对象，查找器可以用来对返回的规格进行更有依据的猜测。在实现具体的 <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code> 代码时，可能会用到 <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于查找指定的模块中 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的遗留方法。如果这是最高层级的导入，<em>path</em> 的值将会是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。否则，这是一个查找子包或者模块的方法，并且 <em>path</em> 的值将会是来自父包的 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 的值。如果未发现加载器，返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果定义了 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 方法，则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当调用这个方法的时候返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。 可以使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来提供功能。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>当被调用的时候，一个可选的方法应该将查找器使用的任何内部缓存进行无效。将在 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 上的所有查找器的缓存进行无效的时候，这个函数被 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a> 所使用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当方法被调用的时候，方法返回是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="永久链接至目标">¶</a></dt>
<dd><p>一个抽象基类，代表  <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>。虽然与 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> 有些相似之处，但 <cite>PathEntryFinder</cite> 仅用于 <a class="reference internal" href="#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a> 提供的基于路径的导入子系统中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>不再是 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a> 的子类。</p>
</div>
<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>一个抽象方法，用于查找指定模块的 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>。搜索器将只在指定的 <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> 内搜索该模块。找不到则会返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。在实现具体的 <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code> 代码时，可能会用到  <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于在模块中查找一个 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的遗留方法。 返回一个 <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code> 的2元组，<code class="docutils literal notranslate"><span class="pre">portion</span></code> 是一个贡献给命名空间包部分的文件系统位置的序列。 加载器可能是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，同时正在指定的 <code class="docutils literal notranslate"><span class="pre">portion</span></code> 表示的是贡献给命名空间包的文件系统位置。<code class="docutils literal notranslate"><span class="pre">portion</span></code> 可以使用一个空列表来表示加载器不是命名空间包的一部分。 如果 <code class="docutils literal notranslate"><span class="pre">loader</span></code> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 并且 <code class="docutils literal notranslate"><span class="pre">portion</span></code> 是一个空列表，那么命名空间包中无加载器或者文件系统位置可查找到（即在那个模块中未能找到任何东西）。</p>
<p>如果定义了 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> ，则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>返回 <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code> 而不是引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。 当可于提供相应的功能的时候，使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module`的具体实现，该方法等价于``self.find_loader(fullname)[0]`()</span></code>。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>可选方法，调用后应让查找器用到的所有内部缓存失效。要让所有缓存的查找器的缓存无效时，可供 <a class="reference internal" href="#importlib.machinery.PathFinder.invalidate_caches" title="importlib.machinery.PathFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.invalidate_caches()</span></code></a> 调用。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的抽象基类。 关于一个加载器的实际定义请查看 <span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>。</p>
<p>加载器想要支持资源读取应该实现一个由 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a> 指定的``get_resource_reader(fullname)`` 方法。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>引入了可选的 <code class="docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> 方法。</p>
</div>
<dl class="py method">
<dt id="importlib.abc.Loader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="永久链接至目标">¶</a></dt>
<dd><p>当导入一个模块的时候，一个返回将要使用的那个模块对象的方法。这个方法可能返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，这暗示着应该发生默认的模块创建语义。&quot;</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>从 Python 3.6 开始，当定义了 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 的时候，这个方法将不会是可选的。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>当一个模块被导入或重新加载时，一个抽象方法在它自己的命名空间中执行那个模块。当调用 <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> 的时候，那个模块应该已经被初始化 了。当这个方法存在时，必须定义 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 也必须被定义。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>用于加载一个模块的传统方法。如果这个模块不能被导入，将引起 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常，否则返回那个被加载的模块。</p>
<p>如果请求的模块已经存在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>，应该使用并且重新加载那个模块。 否则加载器应该是创建一个新的模块并且在任何家过程开始之前将这个新模块插入到 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，来阻止递归导入。 如果加载器插入了一个模块并且加载失败了，加载器必须从 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中将这个模块移除。在加载器开始执行之前，已经在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中的模块应该被忽略 (查看 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>)。</p>
<p>加载器应该在模块上面设置几个属性。（要知道当重新加载一个模块的时候，那些属性某部分可以改变）：</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>模块的名字</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>模块数据存储的路径(不是为了内置的模块而设置)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>被存储或应该被存储的模块的编译版本的路径（当这个属性不恰当的时候不设置）。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>指定在一个包中搜索路径的一个字符串列表。这个属性不在模块上面进行设置。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>The fully qualified name of the package under which the module was
loaded as a submodule (or the empty string for top-level modules).
For packages, it is the same as <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.  The
<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> decorator can handle the
details for <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>用来加载那个模块的加载器。 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> 装饰器可以处理 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 的细节。</p>
</dd>
</dl>
</li>
</ul>
<p>当 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 可用的时候，那么则提供了向后兼容的功能。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当这个方法被调用的时候，触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。当 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 可用的时候，使用它的功能。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>加载模块推荐的使用的 API 是 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> (和 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>)。 加载器应该实现它而不是 load_module()。 当 exec_module() 被实现的时候，导入机制关心的是 load_module() 所有其他的责任。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.module_repr">
<code class="sig-name descname">module_repr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="永久链接至目标">¶</a></dt>
<dd><p>一个遗留方法，在实现时计算并返回给定模块的 repr，作为字符串。 模块类型的默认 repr() 将根据需要使用此方法的结果。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>是可选的方法而不是一个抽象方法。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>现在导入机制会自动地关注这个方法。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ResourceReader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceReader</code><a class="headerlink" href="#importlib.abc.ResourceReader" title="永久链接至目标">¶</a></dt>
<dd><p><em>被 TraversableResources</em> 取代</p>
<p>提供读取 <em>resources</em> 能力的一个 <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> 。</p>
<p>从这个 ABC 的视角出发，<em>resource</em> 指一个包附带的二进制文件。常见的如在包的  <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> 文件旁的数据文件。这个类存在的目的是为了将对数据文件的访问进行抽象，这样包就和其数据文件的存储方式无关了。不论这些文件是存放在一个 zip 文件里还是直接在文件系统内。</p>
<p>对于该类中的任一方法，<em>resource</em> 参数的值都需要是一个在概念上表示文件名称的 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。 这意味着任何子目录的路径都不该出现在 <em>resouce</em> 参数值内。 因为对于阅读器而言，包的位置就代表着「目录」。 因此目录和文件名就分别对应于包和资源。 这也是该类的实例都需要和一个包直接关联（而不是潜在指代很多包或者一整个模块）的原因。</p>
<p>想支持资源读取的加载器需要提供一个返回实现了此 ABC 的接口的 <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> 方法。如果通过全名指定的模块不是一个包，这个方法应该返回 <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。 当指定的模块是一个包时，应该只返回一个与这个抽象类ABC兼容的对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
<dl class="py method">
<dt id="importlib.abc.ResourceReader.open_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">open_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个打开的 <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> 用于 <em>resource</em> 的二进制读取。</p>
<p>如果无法找到资源，将会引发 <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.resource_path">
<em class="property">abstractmethod </em><code class="sig-name descname">resource_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>resource</em> 的文件系统路径。</p>
<p>如果资源并不实际存在于文件系统中，将会引发 <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.is_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <em>name</em> 被视作资源，则返回True。如果 <em>name</em> 不存在，则引发 <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> 异常。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.contents">
<em class="property">abstractmethod </em><code class="sig-name descname">contents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="永久链接至目标">¶</a></dt>
<dd><p>反回由字符串组成的 <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>，表示这个包的所有内容。 请注意并不要求迭代器返回的所有名称都是实际的资源，例如返回 <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a> 为假值的名称也是可接受的。</p>
<p>允许非资源名字被返回是为了允许存储的一个包和它的资源的方式是已知先验的并且非资源名字会有用的情况。比如，允许返回子目录名字，目的是当得知包和资源存储在文件系统上面的时候，能够直接使用子目录的名字。</p>
<p>这个抽象方法返回了一个不包含任何内容的可迭代对象。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="永久链接至目标">¶</a></dt>
<dd><p>一个 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的抽象基类，它实现了可选的 <span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 协议用于从存储后端加载任意资源。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.7 版后已移除: </span>由于要支持使用 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>  类来加载资源，这个 ABC 已经被弃用了。</p>
</div>
<dl class="py method">
<dt id="importlib.abc.ResourceLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于返回位于 <em>path</em> 的字节数据的抽象方法。有一个允许存储任意数据的类文件存储后端的加载器能够实现这个抽象方法来直接访问这些被存储的数据。如果不能够找到 <em>path</em>，则会引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。<em>path</em> 被希望使用一个模块的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file</span></code> 属性或来自一个包的 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 来构建。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 异常。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="永久链接至目标">¶</a></dt>
<dd><p>一个实现加载器检查模块可选的 <span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 协议的 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 的抽象基类。</p>
<dl class="py method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个模块的代码对象，或如果模块没有一个代码对象（例如，对于内置的模块来说，这会是这种情况），则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果加载器不能找到请求的模块，则引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>当这个方法有一个默认的实现的时候，出于性能方面的考虑，如果有可能的话，建议覆盖它。</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">在 3.4 版更改: </span>不再抽象并且提供一个具体的实现。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.get_source">
<em class="property">abstractmethod </em><code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>一个返回模块源的抽象方法。使用 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 作为文本字符串被返回，将所有可识别行分割符翻译成 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> 字符。 如果没有可用的源（例如，一个内置模块），则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 如果加载器不能找到指定的模块，则引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>可选方法，如果模块为包，则返回 True，否则返回 False。 如果 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 找不到模块，则会触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.source_to_code">
<em class="property">static </em><code class="sig-name descname">source_to_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">'&lt;string&gt;'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="永久链接至目标">¶</a></dt>
<dd><p>创建一个来自Python源码的代码对象。</p>
<p>参数 <em>data</em> 可以是任意 <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 函数支持的类型（例如字符串或字节串）。 参数 <em>path</em> 应该是源代码来源的路径，这可能是一个抽象概念（例如位于一个 zip 文件中）。</p>
<p>在有后续代码对象的情况下，可以在一个模块中通过运行``exec(code, module.__dict__)``来执行它。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>使得这个方法变成静态的。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> 的实现。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a> 的实现。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 来代替。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="永久链接至目标">¶</a></dt>
<dd><p>一个继承自 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> 的抽象基类，当被实现时，帮助一个模块作为脚本来执行。 这个抽象基类表示可选的 <span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> 协议。</p>
<dl class="py method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>一个用来为指定模块返回 <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 的值的抽象方法。如果无路径可用，则引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p>
<p>如果源代码可用，那么这个方法返回源文件的路径，不管是否是用来加载模块的字节码。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 而不是 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">FileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="永久链接至目标">¶</a></dt>
<dd><p>一个继承自 <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> 和 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>，提供 <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a> 和 <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a> 具体实现的抽象基类。</p>
<p>参数 <em>fullname</em> 是加载器要处理的模块的完全解析的名字。参数 <em>path</em> 是模块文件的路径。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>加载器可以处理的模块的名字。</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>模块的文件路径</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>调用super的``load_module()``。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="永久链接至目标">¶</a></dt>
<dd><p>读取 <em>path</em> 作为二进制文件并且返回来自它的字节数据。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于实现源文件（和可选地字节码）加载的抽象基类。这个类继承自 <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> 和 <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>，需要实现：</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>应该是只返回源文件的路径；不支持无源加载。</p>
</dd>
</dl>
</li>
</ul>
<p>由这个类定义的抽象方法用来添加可选的字节码文件支持。不实现这些可选的方法（或导致它们引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 异常）导致这个加载器只能与源代码一起工作。 实现这些方法允许加载器能与源 <em>和</em> 字节码文件一起工作。不允许只提供字节码的 <em>无源式</em> 加载。字节码文件是通过移除 Python 编译器的解析步骤来加速加载的优化，并且因此没有开放出字节码专用的 API。</p>
<dl class="py method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个包含关于指定路径的元数据的 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的可选的抽象方法。 支持的字典键有：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (必选项): 一个表示源码修改时间的整数或浮点数；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (可选项)：源码的字节大小。</p></li>
</ul>
<p>字典中任何其他键会被忽略，以允许将来的扩展。 如果不能处理该路径，则会引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 而不是 <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="sig-name descname">path_mtime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="永久链接至目标">¶</a></dt>
<dd><p>返回指定文件路径修改时间的可选的抽象方法。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.3 版后已移除: </span>在有了 <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a> 的情况下，这个方法被弃用了。 没必要去实现它了，但是为了兼容性，它依然处于可用状态。 如果文件路径不能被处理，则引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 而不是 <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="永久链接至目标">¶</a></dt>
<dd><p>往一个文件路径写入指定字节的的可选的抽象方法。任何中间不存在的目录不会被自动创建。</p>
<p>由于路径是只读的，当写入的路径产生错误时（<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>），不会传播异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>当被调用时，不再引起 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 异常。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a> 的具体实现。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> 的具体实现。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a> 的具体实现。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a> 的具体实现。一个模块被确定为一个包的条件是：它的文件路径（由 <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a> 提供）当文件扩展名被移除时是一个命名为 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 的文件，<strong>并且</strong> 这个模块名字本身不是以``__init__``结束。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.Traversable">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Traversable</code><a class="headerlink" href="#importlib.abc.Traversable" title="永久链接至目标">¶</a></dt>
<dd><p>拥有部分 pathlib.Path 方法的对象，适用于遍历目录和打开文件。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
<dl class="py method">
<dt id="importlib.abc.Traversable.name">
<em class="property">abstractmethod </em><code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.name" title="永久链接至目标">¶</a></dt>
<dd><p>The base name of this object without any parent references.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.iterdir">
<em class="property">abstractmethod </em><code class="sig-name descname">iterdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.iterdir" title="永久链接至目标">¶</a></dt>
<dd><p>Yield Traversable objects in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.is_dir">
<em class="property">abstractmethod </em><code class="sig-name descname">is_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_dir" title="永久链接至目标">¶</a></dt>
<dd><p>Return True if self is a directory.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.is_file">
<em class="property">abstractmethod </em><code class="sig-name descname">is_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_file" title="永久链接至目标">¶</a></dt>
<dd><p>Return True if self is a file.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.joinpath">
<em class="property">abstractmethod </em><code class="sig-name descname">joinpath</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.joinpath" title="永久链接至目标">¶</a></dt>
<dd><p>Return Traversable child in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.__truediv__">
<em class="property">abstractmethod </em><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.__truediv__" title="永久链接至目标">¶</a></dt>
<dd><p>Return Traversable child in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.open">
<em class="property">abstractmethod </em><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'r'</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.open" title="永久链接至目标">¶</a></dt>
<dd><p><em>mode</em> may be 'r' or 'rb' to open as text or binary. Return a handle
suitable for reading (same as <a class="reference internal" href="pathlib.html#pathlib.Path.open" title="pathlib.Path.open"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pathlib.Path.open</span></code></a>).</p>
<p>When opening as text, accepts encoding parameters such as those
accepted by <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.read_bytes">
<code class="sig-name descname">read_bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_bytes" title="永久链接至目标">¶</a></dt>
<dd><p>Read contents of self as bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.read_text">
<code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_text" title="永久链接至目标">¶</a></dt>
<dd><p>Read contents of self as text.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.TraversableResources">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">TraversableResources</code><a class="headerlink" href="#importlib.abc.TraversableResources" title="永久链接至目标">¶</a></dt>
<dd><p>用作资源读取器的抽象基类，能够为 <code class="docutils literal notranslate"><span class="pre">files</span></code> 接口提供服务。其为ResourceReader 的子类，并具体实现了 ResourceReader 的抽象方法。因此，任何提供 TraversableReader 的加载器也提供 ResourceReader。</p>
<p>需要支持资源读取的加载器应实现此接口。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="module-importlib.resources">
<span id="importlib-resources-resources"></span><h2><a class="reference internal" href="#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> -- 资源<a class="headerlink" href="#module-importlib.resources" title="永久链接至标题">¶</a></h2>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/resources.py">Lib/importlib/resources.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
<p>这个模块使得Python的导入系统提供了访问 <em>包</em> 内的 <em>资源</em> 的功能。如果能够导入一个包，那么就能够访问那个包里面的资源。资源可以以二进制或文本模式方式被打开或读取。</p>
<p>资源非常类似于目录内部的文件，要牢记的是这仅仅是一个比喻。资源和包不是与文件系统上的物理文件和目录一样存在着。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本模块提供了类似于 <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a>  <a class="reference external" href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Basic Resource Access</a> 的功能，但没有该包的性能开销。这样读取包中的资源就更为容易，语义也更稳定一致。</p>
<p>该模块有独立的向下移植版本， <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/using.html">using importlib.resources</a>  和 <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/migration.html">migrating from pkg_resources to importlib.resources</a>  提供了更多信息。</p>
</div>
<p>加载器想要支持资源读取应该实现一个由 <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a> 指定的``get_resource_reader(fullname)`` 方法。</p>
<p>定义了以下类型。</p>
<dl class="py data">
<dt id="importlib.resources.Package">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Package</code><a class="headerlink" href="#importlib.resources.Package" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Package</span></code> 类型定义为 <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">ModuleType]</span></code> 。这意味着只要函数说明接受 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 的地方，就可以传入字符串或模块。模块对象必须拥有一个可解析的 <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>，不能是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py data">
<dt id="importlib.resources.Resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Resource</code><a class="headerlink" href="#importlib.resources.Resource" title="永久链接至目标">¶</a></dt>
<dd><p>此类型描述了传入本包各函数的资源名称。定义为 <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">os.PathLike]</span></code>。</p>
</dd></dl>

<p>有以下函数可用：</p>
<dl class="py function">
<dt id="importlib.resources.files">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.files" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code> 对象，代表包的资源容器（可视为目录）及其资源（可视为文件）。Traversable 可以包含其他容器（可视为子目录）。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.as_file">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">as_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traversable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.as_file" title="永久链接至目标">¶</a></dt>
<dd><p>给出代表某个文件的 <code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code> 对象，通常是来自 <a class="reference internal" href="#importlib.resources.files" title="importlib.resources.files"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.files()</span></code></a>，返回上下文管理器以供 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句使用。上下文管理器提供一个 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> 对象。</p>
<p>退出上下文管理程序时，可以清理所有临时文件，比如从压缩文件中提取资源时创建的那些文件。</p>
<p>如果 Traversable 方法（<code class="docutils literal notranslate"><span class="pre">read_text</span></code> 等）不够用，需要文件系统中的实际文件时，请使用 <code class="docutils literal notranslate"><span class="pre">as_file</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.open_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_binary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_binary" title="永久链接至目标">¶</a></dt>
<dd><p>以二进制读方式打开 <em>package</em> 内的 <em>resource</em>。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。 <em>resource</em> 是要在 <em>package</em> 内打开的资源名；不能包含路径分隔符，也不能有子资源（即不能为目录）。本函数将返回一个``typing.BinaryIO`` 实例以供读取，即一个已打开的二进制 I/O 流。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.open_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'strict'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_text" title="永久链接至目标">¶</a></dt>
<dd><p>以文本读方式打开 <em>package</em> 内的 <em>resource</em>。默认情况下，资源将以 UTF-8 格式打开以供读取。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。 <em>resource</em> 是要在 <em>package</em> 内打开的资源名；不能包含路径分隔符，也不能有子资源（即不能是目录）。<em>encoding</em> 和 <em>errors</em> 的含义与内置 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 的一样。</p>
<p>本函数返回一个 <code class="docutils literal notranslate"><span class="pre">typing.TextIO</span></code> 实例，即一个打开的文本 I/O  流对象以供读取。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.read_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_binary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_binary" title="永久链接至目标">¶</a></dt>
<dd><p>读取并返回 <em>package</em> 中的 <em>resource</em> 内容，格式为 <code class="docutils literal notranslate"><span class="pre">bytes</span></code>。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。 <em>resource</em> 是要在 <em>package</em> 内打开的资源名；不能包含路径分隔符，也不能有子资源（即不能是目录）。资源内容以 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的形式返回。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.read_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'strict'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_text" title="永久链接至目标">¶</a></dt>
<dd><p>读取并返回 <em>package</em> 中 <em>resource</em> 的内容，格式为 <code class="docutils literal notranslate"><span class="pre">str</span></code>。默认情况下，资源内容将以严格的 UTF-8 格式读取。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。 <em>resource</em> 是要在 <em>package</em> 内打开的资源名；不能包含路径分隔符，也不能有子资源（即不能是目录）。<em>encoding</em> 和 <em>errors</em> 的含义与内置 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 的一样。资源内容将以 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 的形式返回。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.path">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.path" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <em>resource</em> 实际的文件系统路径。本函数返回一个上下文管理器，以供 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用。上下文管理器提供一个 <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> 对象。</p>
<p>退出上下文管理程序时，可以清理所有临时文件，比如从压缩文件中提取资源时创建的那些文件。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。 <em>resource</em> 是要在 <em>package</em> 内打开的资源名；不能包含路径分隔符，也不能有子资源（即不能是目录）。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.is_resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.is_resource" title="永久链接至目标">¶</a></dt>
<dd><p>如果包中存在名为 <em>name</em> 的资源，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 请记住，目录 <em>不是</em> 资源！ <em>package</em> 为包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.contents">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">contents</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.contents" title="永久链接至目标">¶</a></dt>
<dd><p>返回一个用于遍历包内各命名项的可迭代对象。该可迭代对象将返回 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 资源（如文件）及非资源（如目录）。该迭代器不会递归进入子目录。</p>
<p><em>package</em> 是包名或符合 <code class="docutils literal notranslate"><span class="pre">Package</span></code> 要求的模块对象。</p>
</dd></dl>

</section>
<section id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> —— 导入器和路径钩子函数。<a class="headerlink" href="#module-importlib.machinery" title="永久链接至标题">¶</a></h2>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>本模块包含多个对象，以帮助 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 查找并加载模块。</p>
<dl class="py attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>一个字符串列表，表示源模块的可识别的文件后缀。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>一个字符串列表，表示未经优化字节码模块的文件后缀。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.5 版后已移除: </span>改用 <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> 。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>一个字符串列表，表示已优化字节码模块的文件后缀。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.5 版后已移除: </span>改用 <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> 。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>一个字符串列表，表示字节码模块的可识别的文件后缀（包含前导的句点符号）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>该值不再依赖于 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="永久链接至目标">¶</a></dt>
<dd><p>一个字符串列表，表示扩展模块的可识别的文件后缀。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.machinery.all_suffixes">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="永久链接至目标">¶</a></dt>
<dd><p>返回字符串的组合列表，代表标准导入机制可识别模块的所有文件后缀。这是个助手函数，只需知道某个文件系统路径是否会指向模块，而不需要任何关于模块种类的细节（例如 <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="永久链接至目标">¶</a></dt>
<dd><p>用于导入内置模块的 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>。 所有已知的内置模块都已列入 <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>。 此类实现了 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> 和 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> 抽象基类。</p>
<p>此类只定义类的方法，以减轻实例化的开销。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>作为 <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a> 的一部分，现在内置模块导入器实现了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="永久链接至目标">¶</a></dt>
<dd><p>用于已冻结模块的 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>。 此类实现了 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> 和 <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> 抽象基类。</p>
<p>此类只定义类的方法，以减轻实例化的开销。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>有了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code> 方法。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> 用于查找在 Windows 注册表中声明的模块。该类实现了基础的 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> 。</p>
<p>此类只定义类的方法，以减轻实例化的开销。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>改用 <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 配置。未来版本的 Python 可能不会默认启用该查找器。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="永久链接至目标">¶</a></dt>
<dd><p>用于 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 和包的 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 属性的  <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> 。该类实现了基础的 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a>。</p>
<p>此类只定义类的方法，以减轻实例化的开销。</p>
<dl class="py method">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>类方法试图在 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 或 <em>path</em> 上为 <em>fullname</em> 指定的模块查找 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>。对于每个路径条目，都会查看  <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 。如果找到非 False 的对象，则将其用作 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> 来查找要搜索的模块。如果在 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 中没有找到条目，那会在 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 检索该路径条目的查找器，找到了则和查到的模块信息一起存入 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 。如果查找器没有找到，则缓存中的查找器和模块信息都存为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，然后返回。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>如果当前工作目录不再有效（用空字符串表示），则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，但在 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 中不会有缓存值。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="永久链接至目标">¶</a></dt>
<dd><p>一个过时的 <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 封装对象。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>使用 <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>为所有存于 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 中的查找器，调用其  <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> 方法。 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 中为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的条目将被删除。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 中为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的条目将被删除。</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>调用 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 中的对象，当前工作目录为 <code class="docutils literal notranslate"><span class="pre">''</span></code> (即空字符串)。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FileFinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">loader_details</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> 的一个具体实现，它会缓存来自文件系统的结果。</p>
<p>参数 <em>path</em> 是查找器负责搜索的目录。</p>
<p><em>loader_details</em> 参数是数量不定的二元组，每个元组包含加载器及其可识别的文件后缀列表。加载器应为可调用对象，可接受两个参数，即模块的名称和已找到文件的路径。</p>
<p>查找器将按需对目录内容进行缓存，通过对每个模块的检索进行状态统计，验证缓存是否过期。因为缓存的滞后性依赖于操作系统文件系统状态信息的粒度，所以搜索模块、新建文件、然后搜索新文件代表的模块，这会存在竞争状态。如果这些操作的频率太快，甚至小于状态统计的粒度，那么模块搜索将会失败。为了防止这种情况发生，在动态创建模块时，请确保调用 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="永久链接至目标">¶</a></dt>
<dd><p>查找器将要搜索的路径。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>尝试在 <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 中找到处理 <em>fullname</em> 的规格。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="永久链接至目标">¶</a></dt>
<dd><p>试图在 <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 内找到处理 <em>fullname</em> 的加载器。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.10 版后已移除: </span>使用 <a class="reference internal" href="#importlib.machinery.FileFinder.find_spec" title="importlib.machinery.FileFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> 来代替。</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="永久链接至目标">¶</a></dt>
<dd><p>清理内部缓存。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="sig-name descname">path_hook</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">loader_details</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="永久链接至目标">¶</a></dt>
<dd><p>一个类方法，返回供 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 使用的闭包。根据直接给出的路径参数和间接给出的 <em>loader_details</em>，闭包会返回一个 <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> 的实例。</p>
<p>如果给闭包的参数不是已存在的目录，将会触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourceFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> 的一个具体实现，该实现子类化了 <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> 并提供了其他一些方法的具体实现。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>该加载器将要处理的模块名称。</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>源文件的路径</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>如果 <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 看似包的路径，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a> 的具体代码实现。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a> 的具体代码实现。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 的具体代码实现，这里要加载的模块名是可选的。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>改用 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> 。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> 的具体代码实现，可导入字节码文件（也即源代码文件不存在）。</p>
<p>请注意，直接用字节码文件（而不是源代码文件），会让模块无法应用于所有的 Python 版本或字节码格式有所改动的新版本 Python。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>加载器将要处理的模块名。</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>二进制码文件的路径。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 确定该模块是否为包。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>返回由 <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> 创建的 <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 的代码对象。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>因为用此加载器时字节码文件没有源码文件，所以返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 的具体代码实现，这里要加载的模块名是可选的。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.6 版后已移除: </span>改用 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> 。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> 的具体代码实现，用于扩展模块。</p>
<p>参数 <em>fullname</em> 指定了加载器要支持的模块名。参数 <em>path</em> 是指向扩展模块文件的路径。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="永久链接至目标">¶</a></dt>
<dd><p>装载器支持的模块名。</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="永久链接至目标">¶</a></dt>
<dd><p>扩展模块的路径。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a> ，由给定规范创建模块对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>，初始化给定的模块对象。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="永久链接至目标">¶</a></dt>
<dd><p>根据 <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a> ，如果文件路径指向某个包的 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 模块，则返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，因为扩展模块缺少代码对象。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，因为扩展模块没有源代码。</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ModuleSpec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loader_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="永久链接至目标">¶</a></dt>
<dd><p>关于模块导入系统相关状态的规范。通常这是作为模块的 <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> 属性暴露出来。 在以下描述中，括号里的名字给出了模块对象中直接可用的属性。比如 <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>。 但是请注意，虽然 <em>值</em> 通常是相等的，但它们可以不同，因为两个对象之间没有进行同步。因此 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 有可能在运行时做过更新，而这不会自动反映在 <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code> 中。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__name__</span></code>）</p>
<p>A string for the fully qualified name of the module.</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="sig-name descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>）</p>
<p>模块加载时应采用的 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">Loader</span></a> 。 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finders</span></a> 应确保设置本属性。</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__file__</span></code>）</p>
<p>装载模块所在位置的名称，如内置模块为 “buildin”，从源代码加载的模块为文件名。通常应设置 “origin” ，但它可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code> (默认值)，表示未指定 (如命名空间包)。</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="sig-name descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__path__</span></code>）</p>
<p>如果是包（否则为 ），子模块所在位置的字符串列表（否则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>）。</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="sig-name descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>依模块不同的额外数据的容器，以供加载过程中使用（或 <code class="docutils literal notranslate"><span class="pre">None</span></code>）。</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="sig-name descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__cached__</span></code>）</p>
<p>字符串，表示经过编译的模块所在位置（或 <code class="docutils literal notranslate"><span class="pre">None</span></code>）。</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>（<code class="docutils literal notranslate"><span class="pre">__package__</span></code>）</p>
<p>(Read-only) The fully qualified name of the package under which the module
should be loaded as a submodule (or the empty string for top-level modules).
For packages, it is the same as <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="sig-name descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<p>布尔值，表示模块的“origin”属性是否指向可加载的位置。</p>
</dd></dl>

</section>
<section id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> —— 导入器的工具程序代码<a class="headerlink" href="#module-importlib.util" title="永久链接至标题">¶</a></h2>
<p><strong>源代码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>本模块包含了帮助构建 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> 的多个对象。</p>
<dl class="py attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="永久链接至目标">¶</a></dt>
<dd><p>代表字节码版本号的字节串。若要有助于加载/写入字节码，可考虑采用  <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.cache_from_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">cache_from_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">debug_override</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">optimization</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="永久链接至目标">¶</a></dt>
<dd><p>返回 <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> 定义的，与源 <em>path</em> 相关联的已编译字节码文件的路径。 例如，如果 <em>path</em> 为 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> 则 Python 3.2 中的返回值将是 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>。 字符串 <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> 来自于当前的魔法标签 (参见 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; 如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> 未定义则将会引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>)。</p>
<p>参数 <em>optimization</em> 用于指定字节码文件的优化级别。空字符串代表没有优化，所以 <em>optimization</em> 为  的 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>，将会得到字节码路径为 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>。<code class="docutils literal notranslate"><span class="pre">None</span></code> 会导致采用解释器的优化。任何其他字符串都会被采用，所以 <em>optimization</em> 为 <code class="docutils literal notranslate"><span class="pre">''</span></code> 的 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> 会导致字节码路径为 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>。<em>optimization</em> 字符串只能是字母数字，否则会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p><em>debug_override</em> 参数已废弃，可用于覆盖系统的 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 值。<code class="docutils literal notranslate"><span class="pre">True</span></code> 值相当于将 <em>optimization</em> 设为空字符串。<code class="docutils literal notranslate"><span class="pre">False</span></code> 则相当于*optimization* 设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。如果 <em>debug_override</em> 和 <em>optimization</em> 都不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>增加了 <em>optimization</em> 参数，废弃了 <em>debug_override</em> 参数。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.source_from_cache">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_from_cache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="永久链接至目标">¶</a></dt>
<dd><p>根据指向一个 <span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> 文件名的 <em>path</em>，返回相关联的源代码文件路径。 举例来说，如果 <em>path</em> 为 <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> 则返回的路径将是 <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>。 <em>path</em> 不需要已存在，但如果它未遵循 <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> 或 <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> 的格式，则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。 如果未定义 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code>，则会引发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.decode_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">decode_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="永久链接至目标">¶</a></dt>
<dd><p>对代表源代码的字节串进行解码，并将其作为带有通用换行符的字符串返回（符合 <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a> 要求）。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.resolve_name">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">resolve_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="永久链接至目标">¶</a></dt>
<dd><p>将模块的相对名称解析为绝对名称。</p>
<p>如果 <strong>name</strong> 前面没有句点，那就简单地返回 <strong>name</strong>。这样就能采用``importlib.util.resolve_name('sys', __spec__.parent)`` 之类的写法，而无需检查是否需要 <strong>package</strong> 参数。</p>
<p>如果 <strong>name</strong> 是相对模块名称，但 <strong>package</strong> 为 False 值（如 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或空字符串），则会触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。 如果相对名称会离开所在的包（如从 <code class="docutils literal notranslate"><span class="pre">spam</span></code> 包中请求 <code class="docutils literal notranslate"><span class="pre">..bacon</span></code>），则还会触发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.3 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>为了改善与 import 语句的一致性，对于无效的相对导入尝试会引发 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 而不是 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.find_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="永久链接至目标">¶</a></dt>
<dd><p>查找模块的 <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>，相对指定的 <strong>package</strong> 名为可选参数。如果该模块位于 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，则会返回 <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> （除非 spec为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或未作设置，这时会触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>)。否则将用  <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 进行搜索。若找不到则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果 <strong>name</strong> 为一个子模块（带有一个句点），则会自动导入父级模块。</p>
<p><strong>name</strong> 和 <strong>package</strong> 的用法与 <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code> 相同。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>如果 <strong>package</strong> 实际上不是一个包（即缺少 <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> 属性）则会引发 <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> 而不是 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.module_from_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_from_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="永久链接至目标">¶</a></dt>
<dd><p>基于 <strong>spec</strong> 和 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a> 创建一个新模块。</p>
<p>如果 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a> 未返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，那么先前已存在的属性不会被重置。另外，如果 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 是在访问 <strong>spec</strong> 或设置模块属性时触发的，则不会触发 。</p>
<p>本函数比 <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 创建新模块要好，因为用到 <strong>spec</strong> 模块设置了尽可能多的导入控制属性。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.module_for_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 的一个 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>，用来选取合适的模块对象以供加载。被装饰方法的签名应带有两个位置参数（如：<code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>），其中第二个参数将是加载器用到的模块 <strong>对象</strong>。请注意，由于假定有两个参数，所以装饰器对静态方法不起作用。</p>
<p>装饰的方法将接受要加载的模块的 <strong>name</strong>，正如 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> 一样。如果在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中没有找到该模块，那么将构造一个新模块。不管模块来自哪里， <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 设置为 <strong>self</strong> ，并且 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 是根据 <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> 的返回值设置的。这些属性会无条件进行设置以便支持再次加载。</p>
<p>如果被装饰的方法触发异常，并且已有模块加入 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，那么该模块将被移除，以防 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中残留一个部分初始化的模块。如果该模块原先已在 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 中，则会保留不变。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版更改: </span>有可能时自动设置 <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 和 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>无条件设置 <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 、 <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 、 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 以支持再次加载。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>现在，导入机制直接执行本函数提供的所有功能。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.set_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="永久链接至目标">¶</a></dt>
<dd><p>一个 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>，用于 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 在返回的模块上设置 <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 属性。如果该属性已被设置，装饰器就什么都不做。这里假定被封装方法的第一个位置参数（即 <code class="docutils literal notranslate"><span class="pre">self</span></code>）就是 <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 要设置的。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版更改: </span>如果设为 <code class="docutils literal notranslate"><span class="pre">None</span></code> ，则会去设置 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> ，就像该属性不存在一样。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>现在导入机制会自动用到本方法。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.set_package">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="永久链接至目标">¶</a></dt>
<dd><p>一个用于 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> 的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> ，以便设置返回模块的 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 属性。如果 <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 已设置且不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，则不会做改动。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.4 版后已移除: </span>现在导入机制会自动用到本方法。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.spec_from_loader">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="永久链接至目标">¶</a></dt>
<dd><p>一个工厂函数，用于创建基于加载器的 <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> 实例。参数的含义与 ModuleSpec 的相同。该函数会利用当前可用的 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> API，比如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>，以填充所有缺失的规格信息。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.spec_from_file_location">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_file_location</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">loader</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">submodule_search_locations</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="永久链接至目标">¶</a></dt>
<dd><p>一个工厂函数，根据文件路径创建 <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> 实例。缺失的信息将根据 spec 进行填补，利用加载器 API ，以及模块基于文件的隐含条件。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>接受一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.source_hash">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_hash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="永久链接至目标">¶</a></dt>
<dd><p>以字节串的形式返回 <em>source_bytes</em> 的哈希值。基于哈希值的 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件在头部嵌入了对应源文件内容的 <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.util.LazyLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">LazyLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="永久链接至目标">¶</a></dt>
<dd><p>此类会延迟执行模块加载器，直至该模块有一个属性被访问到。</p>
<p>此类 <strong>只</strong> 适用于定义了 <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> 的加载器，因为需要控制模块的类型。 同理，加载器的 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> 方法必须返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或 <code class="docutils literal notranslate"><span class="pre">__class__</span></code>  属性可被改变且不用  <a class="reference internal" href="../glossary.html#term-__slots__"><span class="xref std std-term">slots</span></a> 的类型。 最后，用于替换 <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> 内容的模块将无法工作，因为无法在整个解释器中安全地替换模块的引用；如果检测到这种替换，将触发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果项目对启动时间要求很高，只要模块未被用过，此类能够最小化加载模块的开销。对于启动时间并不重要的项目来说，由于加载过程中产生的错误信息会被暂时搁置，因此强烈不建议使用此类。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>开始调用 <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>，移除 <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> 和 <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a> 的兼容性警告。</p>
</div>
<dl class="py method">
<dt id="importlib.util.LazyLoader.factory">
<em class="property">classmethod </em><code class="sig-name descname">factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="永久链接至目标">¶</a></dt>
<dd><p>静态方法，返回创建延迟加载器的可调用对象。就是说用在加载器用类而不是实例传递的场合。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="examples">
<span id="importlib-examples"></span><h2>例子<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h2>
<section id="importing-programmatically">
<h3>用编程方式导入<a class="headerlink" href="#importing-programmatically" title="永久链接至标题">¶</a></h3>
<p>要以编程方式导入一个模块，请使用 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> ：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="checking-if-a-module-can-be-imported">
<h3>检查某模块可否导入。<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="永久链接至标题">¶</a></h3>
<p>If you need to find out if a module can be imported without actually doing the
import, then you should use <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">name</span></code> is a submodule (contains a dot),
<a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> will import the parent module.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="o">:=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="importing-a-source-file-directly">
<h3>直接导入源码文件。<a class="headerlink" href="#importing-a-source-file-directly" title="永久链接至标题">¶</a></h3>
<p>若要直接导入 Python 源码文件，请使用一下方案（仅 Python 3.5 以上版本有效）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="implementing-lazy-imports">
<h3>实现延迟导入<a class="headerlink" href="#implementing-lazy-imports" title="永久链接至标题">¶</a></h3>
<p>以下例子展示了如何实现延迟导入：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lazy_import</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
<span class="gp">... </span>    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="gp">... </span>    <span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">module</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#lazy_typing is a real module object,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#but it is not loaded in memory yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="setting-up-an-importer">
<h3>导入器的配置<a class="headerlink" href="#setting-up-an-importer" title="永久链接至标题">¶</a></h3>
<p>对于深度定制的导入，通常需要实现一个 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>。 这意味着得同时管理 <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> 和 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>。 根据不同的需求，有两种类型的查找器可供选择： <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> 或 <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>。 前者应位于 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> 之上，而后者是用 <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> 在 <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 上创建但与 <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path</span></code></a> 一起工作，可能会创建一个查找器。以下例子将演示如何注册自己的导入器，以供导入使用（关于自建导入器请阅读本包内定义的类文档）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="approximating-importlib-import-module">
<h3><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 的近似实现<a class="headerlink" href="#approximating-importlib-import-module" title="永久链接至标题">¶</a></h3>
<p>导入过程本身是用 Python 代码实现的，这样就能通过 importlib 将大多数导入机制暴露出来。以下代码近似实现了 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> ，以帮助说明 importlib 暴露出来的各种 API （importlib 的用法适用于 Python 3.4 以上版本 ，其他代码适用于 Python 3.6 以上版本）。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;No module named </span><span class="si">{</span><span class="n">absolute_name</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现</a><ul>
<li><a class="reference internal" href="#introduction">概述</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> —— 关于导入的抽象基类</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> -- 资源</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> —— 导入器和路径钩子函数。</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> —— 导入器的工具程序代码</a></li>
<li><a class="reference internal" href="#examples">例子</a><ul>
<li><a class="reference internal" href="#importing-programmatically">用编程方式导入</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">检查某模块可否导入。</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">直接导入源码文件。</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">实现延迟导入</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">导入器的配置</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> 的近似实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="runpy.html"
                        title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> ——查找并执行 Python  模块</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="下一章">使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/importlib.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="使用 importlib.metadata"
             >下一页</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy ——查找并执行 Python 模块"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >导入模块</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> --- <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 的实现</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 7月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>