
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>typing —— 类型注解支持 &#8212; Python 3.10.5 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.10.5 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="pydoc --- 文档生成器和在线帮助系统" href="pydoc.html" />
    <link rel="prev" title="开发工具" href="development.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="快速搜索"/>
            <input type="submit" value="转向"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 类型注解支持</a><ul>
<li><a class="reference internal" href="#relevant-peps">相关的 PEP</a></li>
<li><a class="reference internal" href="#type-aliases">类型别名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">可调对象（Callable）</a></li>
<li><a class="reference internal" href="#generics">泛型（Generic）</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">用户定义的泛型类型</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 类型</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">名义子类型 vs 结构子类型</a></li>
<li><a class="reference internal" href="#module-contents">模块内容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特殊类型原语</a><ul>
<li><a class="reference internal" href="#special-types">特殊类型</a></li>
<li><a class="reference internal" href="#special-forms">特殊形式</a></li>
<li><a class="reference internal" href="#building-generic-types">构建泛型类型</a></li>
<li><a class="reference internal" href="#other-special-directives">其他特殊指令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">泛型具象容器</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">对应的内置类型</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 对应类型</a></li>
<li><a class="reference internal" href="#other-concrete-types">其他具象类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">抽象基类</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 对应的容器</a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 对应的其他类型</a></li>
<li><a class="reference internal" href="#asynchronous-programming">异步编程</a></li>
<li><a class="reference internal" href="#context-manager-types">上下文管理器类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">协议</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函数与装饰器</a></li>
<li><a class="reference internal" href="#introspection-helpers">内省辅助器</a></li>
<li><a class="reference internal" href="#constant">常量</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="development.html"
                        title="上一章">开发工具</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="pydoc.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文档生成器和在线帮助系统</a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/typing.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文档生成器和在线帮助系统"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 类型注解支持</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> —— 类型注解支持<a class="headerlink" href="#module-typing" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
<p><strong>源码：</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>Python 运行时不强制执行函数和变量类型注解，但这些注解可用于类型检查器、IDE、静态检查器等第三方工具。</p>
</div>
<hr class="docutils" />
<p>这个模块提供对类型提示的运行时支持。最基本的支持包括 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> , <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a> , <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> , <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> , 和 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 。关于完整的规范，请参考 <span class="target" id="index-160"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 。关于类型提示的简化介绍，请参考 <span class="target" id="index-161"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a> 。</p>
<p>下面的函数接收与返回的都是字符串，注解方式如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">greeting</span></code> 函数中，参数 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的类型是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>，返回类型也是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>。子类型也可以当作参数。</p>
<p>新的功能频繁地被添加到 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块中。<a class="reference external" href="https://pypi.org/project/typing-extensions/">typing_extensions</a> 包提供了这些新功能对旧版本 Python 的向后移植。</p>
<section id="relevant-peps">
<span id="id1"></span><h2>相关的 PEP<a class="headerlink" href="#relevant-peps" title="永久链接至标题">¶</a></h2>
<p>自从在 <span class="target" id="index-162"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 和 <span class="target" id="index-163"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a> 中首次引入类型提示以来，一些 PEP 已经修改和增强了 Python 的类型注释框架。包括:</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="target" id="index-164"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>: 变量注解的语法</dt><dd><p><em>引入</em> 在函数定义之外标注变量的语法，以及 <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-165"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>: Protocol：结构子类型（静态鸭子类型）。</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> 和 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code></a> 装饰器。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-166"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>: 标准集合中的类型提示泛型</dt><dd><p><em>引入</em> <a class="reference internal" href="types.html#types.GenericAlias" title="types.GenericAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.GenericAlias</span></code></a> 和使用标准库类作为 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">通用类型</span></a> 的能力。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-167"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>: 文字类型</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-168"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>: TypedDict: 具有固定键集的字典的类型提示</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-169"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>: 为 typing 添加最终限定符</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> 和 <a class="reference internal" href="#typing.final" title="typing.final"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;final</span></code></a> 装饰器</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-170"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a>: 灵活的函数和变量注解</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-171"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0604"><strong>PEP 604</strong></a>: 允许 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> 形式的联合类型写法</dt><dd><p><em>引入</em> <a class="reference internal" href="types.html#types.UnionType" title="types.UnionType"><code class="xref py py-data docutils literal notranslate"><span class="pre">types.UnionType</span></code></a> 和使用二元或运算符 <code class="docutils literal notranslate"><span class="pre">|</span></code> 来表示 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">类型联合</span></a> 的能力。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-172"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a>: 形参规格变量</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-173"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0613"><strong>PEP 613</strong></a>: 显式类型别名</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-174"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0647"><strong>PEP 647</strong></a>: 用户自定义的类型保护器</dt><dd><p><em>引入</em> <a class="reference internal" href="#typing.TypeGuard" title="typing.TypeGuard"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeGuard</span></code></a></p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="type-aliases">
<span id="id2"></span><h2>类型别名<a class="headerlink" href="#type-aliases" title="永久链接至标题">¶</a></h2>
<p>把类型赋给别名，就可以定义类型别名。本例中，<code class="docutils literal notranslate"><span class="pre">Vector</span></code> 和 <code class="docutils literal notranslate"><span class="pre">list[float]</span></code> 相同，可互换：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># typechecks; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>类型别名适用于简化复杂的类型签名。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>注意，<code class="docutils literal notranslate"><span class="pre">None</span></code> 是一种类型提示特例，已被 <code class="docutils literal notranslate"><span class="pre">type(None)</span></code> 取代。</p>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="永久链接至标题">¶</a></h2>
<p>使用 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> 助手来创建不同的类型</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>静态类型检查器把新类型当作原始类型的子类，这种方式适用于捕捉逻辑错误：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># typechecks</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># does not typecheck; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 类型的变量可执行所有 <code class="docutils literal notranslate"><span class="pre">int</span></code> 操作，但返回结果都是 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型。这种方式允许在预期 <code class="docutils literal notranslate"><span class="pre">int</span></code> 时传入 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>，还能防止意外创建无效的 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>注意，这些检查只由静态类型检查器强制执行。在运行时，语句 <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> 将产生一个 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 可调用对象，该对象立即返回你传递给它的任何参数。 这意味着语句 <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> 不会创建一个新的类，也不会引入超出常规函数调用的很多开销。</p>
<p>更确切地说，在运行时，<code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> 表达式总为 True。</p>
<p>创建 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 的子类型是无效的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not typecheck</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>然而，我们可以在 &quot;派生的&quot; <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 的基础上创建一个 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a>。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>同时，<code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> 的类型检查也可以按预期执行。</p>
<p>详见 <span class="target" id="index-175"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>回顾上文，类型别名声明了两种彼此 <em>等价</em> 的类型。 <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> 时，静态类型检查器认为 <code class="docutils literal notranslate"><span class="pre">Alias</span></code> 与 <code class="docutils literal notranslate"><span class="pre">Original</span></code> <em>完全等价</em>。 这种方式适用于简化复杂类型签名。</p>
<p>反之，<code class="docutils literal notranslate"><span class="pre">NewType</span></code> 声明把一种类型当作另一种类型的 <em>子类型</em>。<code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> 时，静态类型检查器把 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 当作 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 的 <em>子类</em> ，即，<code class="docutils literal notranslate"><span class="pre">Original</span></code> 类型的值不能用在预期 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 类型的位置。这种方式适用于以最小运行时成本防止逻辑错误。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是一个函数。 在调用 <code class="docutils literal notranslate"><span class="pre">NewType</span></code> 而不是普通的函数时，会有一些额外的运行时间成本。 然而，这种开销将在 3.11.0 中减少。</p>
</div>
</section>
<section id="callable">
<h2>可调对象（Callable）<a class="headerlink" href="#callable" title="永久链接至标题">¶</a></h2>
<p>预期特定签名回调函数的框架可以用 <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code> 实现类型提示。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>无需指定调用签名，用省略号字面量替换类型提示里的参数列表： <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>，就可以声明可调对象的返回类型。</p>
<p>以其他可调用对象为参数的可调用对象可以使用 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 来表明其参数类型是相互依赖的。此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 操作符。 它们分别采取``Callable[ParamSpecVariable, ReturnType]`` 和 <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> 的形式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 更多信息见 <span class="target" id="index-176"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 的文档提供了在 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 中使用的例子。</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2>泛型（Generic）<a class="headerlink" href="#generics" title="永久链接至标题">¶</a></h2>
<p>容器中，对象的类型信息不能以泛型方式静态推断，因此，抽象基类扩展支持下标，用于表示容器元素的预期类型。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>typing 模块中推出的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 工厂函数实现泛型参数化。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>用户定义的泛型类型<a class="headerlink" href="#user-defined-generic-types" title="永久链接至标题">¶</a></h2>
<p>用户定义的类可以定义为泛型类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code> 是定义类 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> 的基类，该类使用单类型参数 <code class="docutils literal notranslate"><span class="pre">T</span></code>。在该类体内，<code class="docutils literal notranslate"><span class="pre">T</span></code> 是有效的类型。</p>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 基类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> ，因此，<code class="docutils literal notranslate"><span class="pre">LoggedVar[t]</span></code> 也是有效类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>一个泛型可以有任何数量的类型变量。所有种类的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 都可以作为泛型的参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 类型变量的参数应各不相同。下列代码就是无效的：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 支持多重继承：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>继承自泛型类时，可以修正某些类型变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>比如，本例中 <code class="docutils literal notranslate"><span class="pre">MyDict</span></code> 调用的单参数，<code class="docutils literal notranslate"><span class="pre">T</span></code>。</p>
<p>未指定泛型类的类型参数时，每个位置的类型都预设为 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。下例中，<code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> 不是泛型，但却隐式继承了 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</pre></div>
</div>
<p>还支持用户定义的泛型类型别名。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># Return type here is same as Iterable[str] | int</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 不再支持自定义元类。</p>
</div>
<p>用户定义的参数表达式的泛型也通过 <code class="docutils literal notranslate"><span class="pre">Generic[P]</span></code> 形式的参数规范变量来支持。该行为与上面描述的类型变量一致，因为参数规范变量被类型化模块视为一个专门的类型变量。 这方面的一个例外是，一个类型列表可以用来替代 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">]):</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, (&lt;class &#39;dict&#39;&gt;, &lt;class &#39;float&#39;&gt;)]</span>
</pre></div>
</div>
<p>此外，一个只有一个参数规范变量的泛型将接受表格 <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> 中的参数列表，出于美观的考虑也包括 <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> 。 在内部，后者被转换为前者，所以下面的内容是等价的:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[(&lt;class &#39;int&#39;&gt;, &lt;class &#39;str&#39;&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[(&lt;class &#39;int&#39;&gt;, &lt;class &#39;str&#39;&gt;)]</span>
</pre></div>
</div>
<p>请注意，带有 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 的泛型在某些情况下可能不会有正确的``__parameters__``，因为它们主要用于静态类型检查。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 现在可以通过参数表达式进行参数化。参见 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <span class="target" id="index-177"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a> 以了解更多细节。</p>
</div>
<p>抽象基类可作为用户定义的泛型类的基类，且不会与元类冲突。现已不再支持泛型元类。参数化泛型的输出结果会被缓存，typing 模块的大多数类型都可哈希、可进行等价对比。</p>
</section>
<section id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型<a class="headerlink" href="#the-any-type" title="永久链接至标题">¶</a></h2>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 是一种特殊的类型。静态类型检查器认为所有类型均与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容，同样，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 也与所有类型兼容。</p>
<p>也就是说，可对 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值执行任何操作或方法调用，并赋值给任意变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>注意，<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 类型的值赋给更精确的类型时，不执行类型检查。例如，把 <code class="docutils literal notranslate"><span class="pre">a</span></code> 赋给 <code class="docutils literal notranslate"><span class="pre">s</span></code>，在运行时，即便 <code class="docutils literal notranslate"><span class="pre">s</span></code> 已声明为 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型，但接收 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 值时，静态类型检查器也不会报错。</p>
<p>此外，未指定返回值与参数类型的函数，都隐式地默认使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>需要混用动态与静态类型代码时，此操作把 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 当作 <em>应急出口</em>。</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 和 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的区别。与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 相似，所有类型都是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 的子类型。然而，与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 不同，object 不可逆：<a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>不是</em> 其它类型的子类型。</p>
<p>就是说，值的类型是 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 时，类型检查器几乎会拒绝所有对它的操作，并且，把它赋给更精确的类型变量（或返回值）属于类型错误。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Typechecks, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Typechecks, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>，说明值能以类型安全的方式转为任何类型。使用 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>，说明值是动态类型。</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>名义子类型 vs 结构子类型<a class="headerlink" href="#nominal-vs-structural-subtyping" title="永久链接至标题">¶</a></h2>
<p>最初 <span class="target" id="index-178"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 将 Python 静态类型系统定义为使用 <em>名义子类型</em>。这意味着当且仅当类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 是 <code class="docutils literal notranslate"><span class="pre">B</span></code> 的子类时，才满足有类 <code class="docutils literal notranslate"><span class="pre">B</span></code> 预期时使用类 <code class="docutils literal notranslate"><span class="pre">A</span></code> 。</p>
<p>此项要求以前也适用于抽象基类，例如，<a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 。这种方式的问题在于，定义类时必须显式说明，既不 Pythonic，也不是动态类型式 Python 代码的惯用写法。例如，下列代码就遵从了 <span class="target" id="index-179"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 的规范：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-180"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a> 允许用户在类定义时不显式说明基类，从而解决了这一问题，静态类型检查器隐式认为 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> 既是 <code class="docutils literal notranslate"><span class="pre">Sized</span></code> 的子类型，又是 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code> 的子类型。这就是 <em>结构子类型</em> （又称为静态鸭子类型）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p>此外，结构子类型的优势在于，通过继承特殊类 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> ，用户可以定义新的自定义协议（见下文中的例子）。</p>
</section>
<section id="module-contents">
<h2>模块内容<a class="headerlink" href="#module-contents" title="永久链接至标题">¶</a></h2>
<p>本模块定义了下列类、函数和修饰器。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>本模块定义了一些类型，作为标准库中已有的类的子类，从而可以让 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 中的类型变量。Python 3.9 中，这些标准库的类已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code> ，因此，这些类型就变得冗余了。</p>
<p>Python 3.9 弃用了这些冗余类型，但解释器并未提供相应的弃用警告。标记弃用类型的工作留待支持 Python 3.9 及以上版本的类型检查器实现。</p>
<p>Python 3.9.0 发布五年后的首个 Python 发行版将从 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块中移除这些弃用类型。详见 <span class="target" id="index-181"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 《<em>标准集合的类型提示泛型</em>》。</p>
</div>
<section id="special-typing-primitives">
<h3>特殊类型原语<a class="headerlink" href="#special-typing-primitives" title="永久链接至标题">¶</a></h3>
<section id="special-types">
<h4>特殊类型<a class="headerlink" href="#special-types" title="永久链接至标题">¶</a></h4>
<p>这些类型可用于类型注解，但不支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。</p>
<dl class="py data">
<dt id="typing.Any">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Any</code><a class="headerlink" href="#typing.Any" title="永久链接至目标">¶</a></dt>
<dd><p>不受限的特殊类型。</p>
<ul class="simple">
<li><p>所有类型都与 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 兼容。</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 与所有类型都兼容。</p></li>
</ul>
</dd></dl>

<dl class="py data">
<dt id="typing.NoReturn">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NoReturn</code><a class="headerlink" href="#typing.NoReturn" title="永久链接至目标">¶</a></dt>
<dd><p>标记没有返回值的函数的特殊类型。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.2 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.TypeAlias">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypeAlias</code><a class="headerlink" href="#typing.TypeAlias" title="永久链接至目标">¶</a></dt>
<dd><p>用于显式声明 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a> 的特殊标注。 例如:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>关于显式类型别名的更多细节，请参见 <span class="target" id="index-182"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0613"><strong>PEP 613</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>特殊形式<a class="headerlink" href="#special-forms" title="永久链接至标题">¶</a></h4>
<p>可用于类型注解，且支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code> ，每种形式都有其独特的句法。</p>
<dl class="py data">
<dt id="typing.Tuple">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="永久链接至目标">¶</a></dt>
<dd><p>元组类型； <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code> 是二项元组类型，第一个元素的类型是 X，第二个元素的类型是 Y。空元组的类型可写为 <code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>。</p>
<p>例：<code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code> 是二项元组，类型变量分别为 T1 和 T2。<code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code> 是由整数、浮点数、字符串组成的三项元组。</p>
<p>可用省略号字面量指定同质变长元组，例如，<code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code> 。<a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a> 与 <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code> 等价，也与 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 等价。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-183"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Union">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Union</code><a class="headerlink" href="#typing.Union" title="永久链接至目标">¶</a></dt>
<dd><p>联合类型； <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> ，意味着满足 X 或 Y 之一。</p>
<p>要定义一个联合类型，可以使用类似 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> 或简写 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>。建议使用这种简写。细节:</p>
<ul>
<li><p>参数必须是某种类型，且至少有一个。</p></li>
<li><p>联合类型之联合类型会被展平，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>单参数之联合类型就是该参数自身，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>冗余的参数会被跳过，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>比较联合类型，不涉及参数顺序，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Union</span></code> 不能作为子类，也不能实例化。</p></li>
<li><p>不支持 <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code> 这种写法。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版更改: </span>在运行时，不要移除联合类型中的显式子类。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>联合类型现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>。 参见 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Optional">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Optional</code><a class="headerlink" href="#typing.Optional" title="永久链接至目标">¶</a></dt>
<dd><p>可选类型。</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> （或 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code> ） 。</p>
<p>注意，可选类型与含默认值的可选参数不同。含默认值的可选参数不需要在类型注解上添加 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 限定符，因为它仅是可选的。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>另一方面，显式应用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值时，不管该参数是否可选， <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 都适用。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span>可选参数现在可以写成 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>。 参见 <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">联合类型表达式</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Callable">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Callable</code><a class="headerlink" href="#typing.Callable" title="永久链接至目标">¶</a></dt>
<dd><p>可调类型； <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> 是把（int）转为 str 的函数。</p>
<p>下标句法必须与参数列表和返回类型这两个值一起使用。参数列表只能是类型列表或省略号；返回类型只能是单一类型。</p>
<p>没有说明可选参数或关键字参数的句法；这类函数类型很少用作回调类型。<code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code> （省略号字面量）可用于为接受任意数量参数，并返回 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 的可调对象提供类型提示。纯 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> 等价于 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>，进而等价于 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 。</p>
<p>以其他可调用对象为参数的可调用对象可以使用 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 来表明其参数类型是相互依赖的。此外，如果该可调用对象增加或删除了其他可调用对象的参数，可以使用 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 操作符。 它们分别采取``Callable[ParamSpecVariable, ReturnType]`` 和 <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> 的形式。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。 详见 <span class="target" id="index-184"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> 现在支持 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。 更多信息见 <span class="target" id="index-185"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> 的文档提供了使用 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 的例子。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Concatenate">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Concatenate</code><a class="headerlink" href="#typing.Concatenate" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> 和 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 一起使用，对一个高阶可调用对象进行类型注释，该对象可以增加、删除或转换另一个可调用对象的参数。 使用形式为``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``。 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 目前只在作为 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> 的第一个参数时有效。<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的最后一个参数必须是一个 <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>。</p>
<p>例如，为了注释一个装饰器 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code>，它为被装饰的函数提供了 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>，<code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 可以用来表示 <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> 期望一个可调用对象，该对象接收一个 <code class="docutils literal notranslate"><span class="pre">Lock</span></code> 作为第一个参数，并返回一个具有不同类型签名的可调用对象。 在这种情况下，<a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 表示返回的可调用对象的参数类型取决于被传入的可调用程序的参数类型:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Concatenate</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>

<span class="c1"># Use this lock to ensure that only one thread is executing a function</span>
<span class="c1"># at any time.</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">with_lock</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span> <span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># We don&#39;t need to pass in the lock ourselves thanks to the decorator.</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-186"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）。</p></li>
<li><p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> 和 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>。</p></li>
</ul>
</div>
<dl class="py class">
<dt id="typing.Type">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Type</code><span class="sig-paren">(</span><em class="sig-param">Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="永久链接至目标">¶</a></dt>
<dd><p>用 <code class="docutils literal notranslate"><span class="pre">C</span></code> 注解的变量可以接受类型 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的值。反之，用 <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> 注解的变量可以接受类自身的值 — 准确地说，是接受 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的 <em>类对象</em>，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type &#39;int&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type &#39;Type[int]&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type &#39;Type[int]&#39;</span>
</pre></div>
</div>
<p>注意，<code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> 为协变量：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># Accepts User, BasicUser, ProUser, TeamUser, ...</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> 为协变量的意思是指， <code class="docutils literal notranslate"><span class="pre">C</span></code> 的所有子类都应使用与 <code class="docutils literal notranslate"><span class="pre">C</span></code> 相同的构造器签名及类方法签名。类型检查器应标记违反此项规定的内容，但也应允许符合指定基类构造器调用的子类进行构造器调用。<span class="target" id="index-187"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>  修订版将来可能会调整类型检查器对这种特例的处理方式。</p>
<p> <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a> 合法的参数仅有类、<a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 、<a class="reference internal" href="#generics"><span class="std std-ref">类型变量</span></a> 以及上述类型的联合类型。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p> <code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">Type</span></code>，进而等价于 Python 元类架构的根基，<code class="docutils literal notranslate"><span class="pre">type</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-188"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Literal">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Literal</code><a class="headerlink" href="#typing.Literal" title="永久链接至目标">¶</a></dt>
<dd><p>表示类型检查器对应变量或函数参数的值等价于给定字面量（或多个字面量之一）的类型。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="n">MODE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 不能创建子类。在运行时，任意值均可作为 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> 的类型参数，但类型检查器可以对此加以限制。字面量类型详见 <span class="target" id="index-189"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a> 。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9.1 版更改: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> 现在能去除形参的重复。 <code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象的相等性比较不再依赖顺序。 现在如果有某个参数不为 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>，<code class="docutils literal notranslate"><span class="pre">Literal</span></code> 对象在相等性比较期间将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.ClassVar">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="永久链接至目标">¶</a></dt>
<dd><p>标记类变量的特殊类型构造器。</p>
<p>如 <span class="target" id="index-190"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 所述，打包在 ClassVar 内的变量注解是指，给定属性应当用作类变量，而不应设置在类实例上。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 仅接受类型，也不能使用下标。</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 本身不是类，不应用于 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 或 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>。<a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> 不改变 Python 运行时行为，但可以用于第三方类型检查器。例如，类型检查器会认为以下代码有错：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.3 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Final">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Final</code><a class="headerlink" href="#typing.Final" title="永久链接至目标">¶</a></dt>
<dd><p>告知类型检查器某名称不能再次赋值或在子类中重写的特殊类型构造器。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-191"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.Annotated">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Annotated</code><a class="headerlink" href="#typing.Annotated" title="永久链接至目标">¶</a></dt>
<dd><p><span class="target" id="index-192"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a> （<code class="docutils literal notranslate"><span class="pre">灵活函数和变量注解</span></code>）里引入的类型，可以用上下文特定元数据（<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的参数可变，也可能用它的多个组成部分）装饰现有的类型。具体来说，就是类型提示 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 用元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 注解类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>。静态分析或运行时都能使用该元数据。库（或工具）处理类型提示 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> 时，在元数据 <code class="docutils literal notranslate"><span class="pre">x</span></code> 不涉及特殊逻辑的情况下，可忽略该类型提示，仅把它当作类型 <code class="docutils literal notranslate"><span class="pre">T</span></code>。与 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块中现有的 <code class="docutils literal notranslate"><span class="pre">no_type_check</span></code> 功能不同，该功能完全禁用了函数或类的类型检查注解，而 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型则允许对 <code class="docutils literal notranslate"><span class="pre">T</span></code> 进行静态类型检查（可安全地忽略 <code class="docutils literal notranslate"><span class="pre">x</span></code>），也可以在特定应用程序中实现 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的运行时访问。</p>
<p>毕竟，如何解释注解（如有）由处理 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型的工具/库负责。工具/库处理 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型时，扫描所有注解以确定是否需要进行处理（例如，使用 <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>）。</p>
<p>工具/库不支持注解，或遇到未知注解时，应忽略注解，并把注解类型当作底层类型。</p>
<p>是否允许客户端在一个类型上使用多个注解，以及如何合并这些注解，由处理注解的工具决定。</p>
<p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型支持把多个相同（或不同）的单个（或多个）类型注解置于任意节点。因此，使用这些注解的工具/库要负责处理潜在的重复项。例如，执行值范围分析时，应允许以下操作：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>传递 <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> 至 <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> ，即可在运行时访问额外的注解。</p>
<p>语义详情：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 的第一个参数必须是有效类型。</p></li>
<li><p>支持多个类型标注（<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 支持可变参数）：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p>调用 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 至少要有两个参数（<code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code> 是无效的）</p></li>
<li><p>注解的顺序会被保留，且影响等价检查：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>嵌套 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 类型会被展平，元数据从最内层注解依序展开：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>不移除注解重复项：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 可用于嵌套或泛型别名：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">V</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">3.9 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.TypeGuard">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypeGuard</code><a class="headerlink" href="#typing.TypeGuard" title="永久链接至目标">¶</a></dt>
<dd><p>用于注释用户定义的类型保护函数的返回类型的特殊类型化形式。 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 只接受一个单一的类型参数。 在运行时，以这种方式标记的函数应该返回一个布尔值。</p>
<p>PX旨在使 <em>类型缩小</em> 受益--这是静态类型检查器用来确定程序代码流中表达式的更精确类型的一种技术。通常，类型缩小是通过分析条件性代码流并将缩小的结果应用于一个代码块来完成的。 这里的条件表达式有时被称为 &quot;类型保护&quot;:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; type guard</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, type of ``val`` is narrowed to ``float``.</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>有时，使用一个用户定义的布尔函数作为类型保护会很方便。 这样的函数应该使用 <code class="docutils literal notranslate"><span class="pre">TypeGuard[...]</span></code> 作为其返回类型，以提醒静态类型检查器注意这一意图。</p>
<p>对于一个给定的函数，使用 <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> 告诉静态类型检查器:</p>
<ol class="arabic simple">
<li><p>返回值是一个布尔值。</p></li>
<li><p>如果返回值是 <code class="docutils literal notranslate"><span class="pre">True</span></code>，其参数的类型是 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 里面的类型。</p></li>
</ol>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``List[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``val`` remains as ``List[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal notranslate"><span class="pre">is_str_list</span></code> 是一个类或实例方法，那么 <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> 中的类型映射到 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 或 <code class="docutils literal notranslate"><span class="pre">self</span></code> 之后的第二个参数的类型。</p>
<p>简而言之，<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeGuard[TypeB]:</span> <span class="pre">...</span></code> 形式的意思是：如果 <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">True</span></code>，那么 <code class="docutils literal notranslate"><span class="pre">arg</span></code> 将把 <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> 缩小为 <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeB</span></code> 不必是 <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> 的缩小形式，它甚至可以是扩大形式。 主要原因是允许像把 <code class="docutils literal notranslate"><span class="pre">List[object]</span></code> 缩小到 <code class="docutils literal notranslate"><span class="pre">List[str]</span></code> 这样的事情，即使后者不是前者的一个子类型，因为 <code class="docutils literal notranslate"><span class="pre">List</span></code> 是不变的。 编写类型安全的类型防护的责任留给了用户。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> also works with type variables.  For more information, see
<span class="target" id="index-33"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0647"><strong>PEP 647</strong></a> (User-Defined Type Guards).</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types">
<h4>构建泛型类型<a class="headerlink" href="#building-generic-types" title="永久链接至标题">¶</a></h4>
<p>以下内容是创建泛型类型的基石，但不在注解内使用。</p>
<dl class="py class">
<dt id="typing.Generic">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generic</code><a class="headerlink" href="#typing.Generic" title="永久链接至目标">¶</a></dt>
<dd><p>用于泛型类型的抽象基类。</p>
<p>泛型类型一般通过继承含一个或多个类型变量的类实例进行声明。例如，泛型映射类型定义如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>该类的用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="永久链接至目标">¶</a></dt>
<dd><p>类型变量。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p>类型变量主要是为静态类型检查器提供支持，用于泛型类型与泛型函数定义的参数。有关泛型类型，详见 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>。泛型函数的写法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">print_capitalized</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>请注意，类型变量可以是 <em>被绑定的</em> ， <em>被约束的</em> ，或者两者都不是，但不能既是被绑定的 <em>又是</em> 被约束的。</p>
<p>约束类型变量和绑定类型变量在几个重要方面具有不同的语义。使用 <em>约束</em> 类型变量意味着它只能被解析为正好是所给的约束之一:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;a&#39; has type &#39;str&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>  <span class="c1"># Inferred type of variable &#39;b&#39; is &#39;str&#39;,</span>
                                                               <span class="c1"># despite &#39;StringSubclass&#39; being passed in</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either &#39;str&#39; or &#39;bytes&#39; in a function call, but not both</span>
</pre></div>
</div>
<p>然而，使用一个 <em>绑定</em> 类型变量，意味着将使用最具体的类型来解析 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;str&#39;</span>

<span class="k">class</span> <span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>  <span class="c1"># Ok, output has type &#39;StringSubclass&#39;</span>
<span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p>类型变量可以被绑定到具体类型、抽象类型（ ABC 或 protocol ），甚至是类型的联合:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p>Bound type variables are particularly useful for annotating
<a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethods</span></code></a> that serve as alternative constructors.
In the following example (by
<a class="reference external" href="https://www.youtube.com/watch?v=HTLu2DFOdTg">Raymond Hettinger</a>), the
type variable <code class="docutils literal notranslate"><span class="pre">C</span></code> is bound to the <code class="docutils literal notranslate"><span class="pre">Circle</span></code> class through the use of a
forward reference. Using this type variable to annotate the
<code class="docutils literal notranslate"><span class="pre">with_circumference</span></code> classmethod, rather than hardcoding the return type
as <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, means that a type checker can correctly infer the return
type even if the method is called on a subclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Circle&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An abstract circle&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="c1"># Use a type variable to show that the return type</span>
    <span class="c1"># will always be an instance of whatever ``cls`` is</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">with_circumference</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">C</span><span class="p">],</span> <span class="n">circumference</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a circle with the specified circumference&quot;&quot;&quot;</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">circumference</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Tire</span><span class="p">(</span><span class="n">Circle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A specialised circle (made out of rubber)&quot;&quot;&quot;</span>

    <span class="n">MATERIAL</span> <span class="o">=</span> <span class="s1">&#39;rubber&#39;</span>


<span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="o">.</span><span class="n">with_circumference</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;c&#39; has type &#39;Circle&#39;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tire</span><span class="o">.</span><span class="n">with_circumference</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;t&#39; has type &#39;Tire&#39; (not &#39;Circle&#39;)</span>
</pre></div>
</div>
<p>在运行时，<code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> 会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。一般而言，<a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 不应与类型搭配使用。</p>
<p>类型变量可以通过传递 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 来标记协变或反变。 更多细节请参见 <span class="target" id="index-194"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 。 默认情况下，类型变量是不变的。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.ParamSpec">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ParamSpec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">bound</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">covariant</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">contravariant</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec" title="永久链接至目标">¶</a></dt>
<dd><p>参数规范变量。 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">类型变量</span></code></a> 的一个专门版本。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>参数规范变量的存在主要是为了使静态类型检查器受益。 它们被用来将一个可调用对象的参数类型转发给另一个可调用对象的参数类型——这种模式通常出现在高阶函数和装饰器中。 它们只有在 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 中使用时才有效，或者作为 <code class="docutils literal notranslate"><span class="pre">Callable</span></code> 的第一个参数，或者作为用户定义的泛型的参数。 参见 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 以了解更多关于泛型的信息。</p>
<p>例如，为了给一个函数添加基本的日志记录，我们可以创建一个装饰器 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 来记录函数调用。 参数规范变量告诉类型检查器，传入装饰器的可调用对象和由其返回的新可调用对象有相互依赖的类型参数:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">ParamSpec</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_logging</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>如果没有 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>，以前注释这个的最简单的方法是使用一个 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> 与绑定 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>。</p>
<ol class="arabic simple">
<li><p>类型检查器不能对 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数进行类型检查，因为 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> 的类型必须是 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>。</p></li>
<li><p><a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 在返回 <code class="docutils literal notranslate"><span class="pre">inner</span></code> 函数时，可能需要在 <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> 装饰器的主体中进行，或者必须告诉静态类型检查器忽略 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>。</p></li>
</ol>
<dl class="py attribute">
<dt id="typing.ParamSpec.args">
<code class="sig-name descname">args</code><a class="headerlink" href="#typing.ParamSpec.args" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="typing.ParamSpec.kwargs">
<code class="sig-name descname">kwargs</code><a class="headerlink" href="#typing.ParamSpec.kwargs" title="永久链接至目标">¶</a></dt>
<dd><p>由于 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 同时捕获了位置参数和关键字参数，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 可以用来将 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 分割成其组成部分。 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 代表给定调用中的位置参数的元组，只能用于注释 <code class="docutils literal notranslate"><span class="pre">*args</span></code>。 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 代表给定调用中的关键字参数到其值的映射，只能用于注释 <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>。在运行时，<code class="docutils literal notranslate"><span class="pre">P.args</span></code> 和 <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 分别是 <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> 和 <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a> 的实例。</p>
</dd></dl>

<p>用 <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> 创建的参数规范变量可以用来声明协变或禁变的通用类型。 参数 <code class="docutils literal notranslate"><span class="pre">bound</span></code> 也被接受，类似于 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>。 然而这些关键字的实际语义还有待决定。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>只有在全局范围内定义的参数规范变量可以被 pickle。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<ul class="simple">
<li><p><span class="target" id="index-195"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0612"><strong>PEP 612</strong></a> -- 参数规范变量（引入 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> 的 PEP）。</p></li>
<li><p><a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a> 和 <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a>。</p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.ParamSpecArgs">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ParamSpecArgs</code><a class="headerlink" href="#typing.ParamSpecArgs" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="typing.ParamSpecKwargs">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ParamSpecKwargs</code><a class="headerlink" href="#typing.ParamSpecKwargs" title="永久链接至目标">¶</a></dt>
<dd><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec`的参数和关键字参数属性。``ParamSpec`</span></code> 的 <code class="docutils literal notranslate"><span class="pre">P.args</span></code> 属性是 <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code> 的一个实例，<code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> 是 <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code> 的一个实例。 它们的目的是用于运行时内部检查的，对静态类型检查器没有特殊意义。</p>
<p>在这些对象中的任何一个上调用 <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a>，都会返回原始的 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># returns P</span>
<span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># returns P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="typing.AnyStr">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 定义为 <code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code> 的 <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">约束类型变量</span></code></a> 。</p>
<p>这里指的是，它可以接受任意同类字符串，但不支持混用不同类别的字符串。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Protocol">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Protocol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Generic</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="永久链接至目标">¶</a></dt>
<dd><p>Protocol 类的基类。Protocol 类的定义如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>这些类主要与静态类型检查器搭配使用，用来识别结构子类型（静态鸭子类型），例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p>详见 <span class="target" id="index-196"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>。Protocol 类用 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> （见下文）装饰，忽略类型签名，仅检查给定属性是否存在，充当简要的运行时协议。</p>
<p>Protocol 类可以是泛型，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="typing.runtime_checkable">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">runtime_checkable</code><a class="headerlink" href="#typing.runtime_checkable" title="永久链接至目标">¶</a></dt>
<dd><p>用于把 Protocol 类标记为运行时协议。</p>
<p>该协议可以与 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 一起使用。应用于非协议的类时，会触发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。该指令支持简易结构检查，与 <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 的 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 非常类似，只擅长做一件事。  例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> 将只检查所需方法的存在，而不是其类型签名。 例如， <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> 是一个类，因此它通过了 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 对 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> 的检查。 然而， <code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__()</span></code> 方法的存在只是为了引发一个 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 的更多信息，因此使它无法调用（实例化） <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="other-special-directives">
<h4>其他特殊指令<a class="headerlink" href="#other-special-directives" title="永久链接至标题">¶</a></h4>
<p>这些特殊指令是声明类型的基石，但不在注解内使用。</p>
<dl class="py class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 的类型版本。</p>
<p>用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>这相当于：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>为字段提供默认值，要在类体内赋值：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>带默认值的字段必须在不带默认值的字段后面。</p>
<p>由此产生的类有一个额外的属性 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> ，给出一个 dict ，将字段名映射到字段类型。（字段名在 <code class="docutils literal notranslate"><span class="pre">_fields</span></code> 属性中，默认值在 <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> 属性中，这两者都是 <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a> API 的一部分。）</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 子类也支持文档字符串与方法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>反向兼容用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>添加了对 <span class="target" id="index-197"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 中变量注解句法的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6.1 版更改: </span>添加了对默认值、方法、文档字符串的支持。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性现已使用常规字典，不再使用 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 实例。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span>移除了 <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 属性， 改用具有相同信息，但更标准的  <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 属性。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.NewType">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NewType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">tp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="永久链接至目标">¶</a></dt>
<dd><p>一个辅助类，用于向类型检查器指示一个不同的类型，见 <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>。在运行时，它返回一个对象，在调用时返回其参数。用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版更改: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> 现在是一个类而不是函数。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.TypedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypedDict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="永久链接至目标">¶</a></dt>
<dd><p>把类型提示添加至字典的特殊构造器。在运行时，它是纯 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>。</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 声明一个字典类型，该类型预期所有实例都具有一组键集，其中，每个键都与对应类型的值关联。运行时不检查此预期，而是由类型检查器强制执行。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了允许在不支持 <span class="target" id="index-198"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 的旧版本的 Python 中使用这个特性， <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 支持另外两种等价的语法形式:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
<p>当任何一个键不是有效的 <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">标识符</span></a> 时，例如因为它们是关键字或包含连字符，也应该使用函数式语法。例子:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>默认情况下，所有的键都必须出现在一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中。 可以通过指定总数来重写这一点。用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>这意味着一个 <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以省略任何一个键。 类型检查器只需要支持一个字面的 <code class="docutils literal notranslate"><span class="pre">False</span></code> 或 <code class="docutils literal notranslate"><span class="pre">True</span></code> 作为 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数的值。 <code class="docutils literal notranslate"><span class="pre">True</span></code> 是默认的，它使类主体中定义的所有项目都是必需的。</p>
<p>一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型有可能使用基于类的语法从一个或多个其他 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类型继承。用法:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> 有三个项目 : <code class="docutils literal notranslate"><span class="pre">x</span></code> , <code class="docutils literal notranslate"><span class="pre">y</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z</span></code> 。 其等价于定义:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 不能继承于一个非 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 类，其中特别包括 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> 。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">XT</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 可以通过注解字典（参见 <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">对象注解属性的最佳实践</span></a> 了解更多关于注解的最佳实践）、 <a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a> 、 <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> 和 <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> 进行内省。</p>
<dl class="py attribute">
<dt id="typing.TypedDict.__total__">
<code class="sig-name descname">__total__</code><a class="headerlink" href="#typing.TypedDict.__total__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> gives the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument.
Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="typing.TypedDict.__required_keys__">
<code class="sig-name descname">__required_keys__</code><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="typing.TypedDict.__optional_keys__">
<code class="sig-name descname">__optional_keys__</code><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> 分别返回 <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 对象，其中包含必需和非必需键。目前，在同一个  中声明必需和非必需键的唯一方法是混合继承，用一个 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数值声明一个 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> ，然后从另一个 <code class="docutils literal notranslate"><span class="pre">total</span></code> 参数值不同的 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 中继承它。用法：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<p>更多示例与 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> 的详细规则，详见 <span class="target" id="index-199"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="generic-concrete-collections">
<h3>泛型具象容器<a class="headerlink" href="#generic-concrete-collections" title="永久链接至标题">¶</a></h3>
<section id="corresponding-to-built-in-types">
<h4>对应的内置类型<a class="headerlink" href="#corresponding-to-built-in-types" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.Dict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Dict</code><span class="sig-paren">(</span><em class="sig-param">dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 的泛型版本。适用于注解返回类型。注解参数时，最好使用 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 等抽象容器类型。</p>
<p>该类型用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-200"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.List">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">List</code><span class="sig-paren">(</span><em class="sig-param">list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 的泛型版本。适用于注解返回类型。注解参数时，最好使用 <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> 或 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> 等抽象容器类型。</p>
<p>该类型用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-201"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Set">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Set</code><span class="sig-paren">(</span><em class="sig-param">set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 的泛型版本。适用于注解返回类型。注解参数时，最好使用 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a> 等抽象容器类型。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-202"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">FrozenSet</code><span class="sig-paren">(</span><em class="sig-param">frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-203"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">注解</p>
<p><a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a> 是一种特殊形式。</p>
</div>
</section>
<section id="corresponding-to-types-in-collections">
<h4><a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 对应类型<a class="headerlink" href="#corresponding-to-types-in-collections" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">DefaultDict</code><span class="sig-paren">(</span><em class="sig-param">collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-204"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.OrderedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">OrderedDict</code><span class="sig-paren">(</span><em class="sig-param">collections.OrderedDict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.7.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-205"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ChainMap</code><span class="sig-paren">(</span><em class="sig-param">collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-206"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Counter">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Counter</code><span class="sig-paren">(</span><em class="sig-param">collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-207"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Deque">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Deque</code><span class="sig-paren">(</span><em class="sig-param">deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-208"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="other-concrete-types">
<h4>其他具象类型<a class="headerlink" href="#other-concrete-types" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.IO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">IO</code><a class="headerlink" href="#typing.IO" title="永久链接至目标">¶</a></dt>
<dt id="typing.TextIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TextIO</code><a class="headerlink" href="#typing.TextIO" title="永久链接至目标">¶</a></dt>
<dt id="typing.BinaryIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">BinaryIO</code><a class="headerlink" href="#typing.BinaryIO" title="永久链接至目标">¶</a></dt>
<dd><p>泛型类型 <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> 及其子类 <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code> 与 <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code> 表示 I/O 流的类型，例如 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 所返回的对象。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.12: </span><code class="docutils literal notranslate"><span class="pre">typing.io</span></code> 命名空间已被废弃并将被删除。这些类型应该被直接从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Pattern">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Pattern</code><a class="headerlink" href="#typing.Pattern" title="永久链接至目标">¶</a></dt>
<dt id="typing.Match">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Match</code><a class="headerlink" href="#typing.Match" title="永久链接至目标">¶</a></dt>
<dd><p>这些类型对应的是从 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> 和 <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> 返回的类型。 这些类型（及相应的函数）是 <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 中的泛型并可通过编写 <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code> 来具体指定。</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.12: </span><code class="docutils literal notranslate"><span class="pre">typing.re</span></code> 命名空间已被废弃并将被删除。这些类型应该被直接从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 导入。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块中的 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> 与 <code class="docutils literal notranslate"><span class="pre">Match</span></code> 类现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-209"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Text">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Text</code><a class="headerlink" href="#typing.Text" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code> 是 <code class="docutils literal notranslate"><span class="pre">str</span></code> 的别名。提供了对 Python 2 代码的向下兼容：Python 2 中，<code class="docutils literal notranslate"><span class="pre">Text</span></code> 是 <code class="docutils literal notranslate"><span class="pre">unicode</span></code> 的别名。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">Text</span></code> 时，值中必须包含 unicode 字符串，以兼容 Python 2 和 Python 3：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="abstract-base-classes">
<h3>抽象基类<a class="headerlink" href="#abstract-base-classes" title="永久链接至标题">¶</a></h3>
<section id="corresponding-to-collections-in-collections-abc">
<h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 对应的容器<a class="headerlink" href="#corresponding-to-collections-in-collections-abc" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AbstractSet</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>  的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-210"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ByteString</code><span class="sig-paren">(</span><em class="sig-param">Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a> 的泛型版本。</p>
<p>该类型代表了 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>、<a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 等字节序列类型。</p>
<p>作为该类型的简称，<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 可用于标注上述任意类型的参数。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-211"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Collection">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Collection</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.6.0 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-212"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 与 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Container">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Container</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-213"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ItemsView</code><span class="sig-paren">(</span><em class="sig-param">MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-214"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">KeysView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-215"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Mapping</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 的泛型版本。用法如下：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-216"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MappingView</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-217"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableMapping</code><span class="sig-paren">(</span><em class="sig-param">Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-218"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSequence</code><span class="sig-paren">(</span><em class="sig-param">Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-219"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSet</code><span class="sig-paren">(</span><em class="sig-param">AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-220"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span><em class="sig-param">Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-221"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ValuesView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-222"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="corresponding-to-other-types-in-collections-abc">
<h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 对应的其他类型<a class="headerlink" href="#corresponding-to-other-types-in-collections-abc" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-223"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterator</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-224"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Generator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generator</code><span class="sig-paren">(</span><em class="sig-param">Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="永久链接至目标">¶</a></dt>
<dd><p>生成器可以由泛型类型 <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code> 注解。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>注意，与 typing 模块里的其他泛型不同， <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 属于逆变行为，不是协变行为，也是不变行为。</p>
<p>如果生成器只产生值，可将 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 与 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>此外，还可以把生成器的返回类型注解为 <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-225"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> 的别名。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Reversible</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 的泛型版本。</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-226"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Sized">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sized</code><a class="headerlink" href="#typing.Sized" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> 的别名。</p>
</dd></dl>

</section>
<section id="asynchronous-programming">
<h4>异步编程<a class="headerlink" href="#asynchronous-programming" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Coroutine</code><span class="sig-paren">(</span><em class="sig-param">Awaitable[V_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 的泛型版本。类型变量的差异和顺序与 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 的内容相对应，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.3 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-227"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncGenerator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="永久链接至目标">¶</a></dt>
<dd><p>异步生成器可由泛型类型 <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code> 注解。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>与常规生成器不同，异步生成器不能返回值，因此没有 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 类型参数。 与 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> 类似，<code class="docutils literal notranslate"><span class="pre">SendType</span></code> 也属于逆变行为。</p>
<p>如果生成器只产生值，可将 <code class="docutils literal notranslate"><span class="pre">SendType</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code>：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>此外，可用 <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code> 或 <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code> 注解生成器的返回类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.1 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-228"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-229"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-230"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Awaitable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-231"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
<section id="context-manager-types">
<h4>上下文管理器类型<a class="headerlink" href="#context-manager-types" title="永久链接至标题">¶</a></h4>
<dl class="py class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.0 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-232"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.AsyncContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="永久链接至目标">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 的泛型版本。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5.4 新版功能.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.6.2 新版功能.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">3.9 版后已移除: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 现已支持 <code class="docutils literal notranslate"><span class="pre">[]</span></code>。详见 <span class="target" id="index-233"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias 类型</span></a>。</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>协议<a class="headerlink" href="#protocols" title="永久链接至标题">¶</a></h3>
<p>这些协议由 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> 装饰。</p>
<dl class="py class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code> 的抽象基类，是其返回类型里的协变量。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__float__</span></code> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsIndex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsIndex</code><a class="headerlink" href="#typing.SupportsIndex" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__index__</span></code> 的抽象基类。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__int__</span></code> 的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="永久链接至目标">¶</a></dt>
<dd><p>含抽象方法 <code class="docutils literal notranslate"><span class="pre">__round__</span></code> 的抽象基类，是其返回类型的协变量。</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>函数与装饰器<a class="headerlink" href="#functions-and-decorators" title="永久链接至标题">¶</a></h3>
<dl class="py function">
<dt id="typing.cast">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">typ</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="永久链接至目标">¶</a></dt>
<dd><p>把值强制转换为类型。</p>
<p>不变更返回值。对类型检查器而言，代表了返回值具有指定的类型，但运行时故意不做任何检查（以便让检查速度尽量快）。</p>
</dd></dl>

<dl class="py function">
<dt id="typing.overload">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">overload</code><a class="headerlink" href="#typing.overload" title="永久链接至目标">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰器可以修饰支持多个不同参数类型组合的函数或方法。<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> - 装饰定义的系列必须紧跟一个非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-装饰定义（用于同一个函数/方法）。<code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-装饰定义仅是为了协助类型检查器， 因为该装饰器会被非 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>-装饰定义覆盖，后者用于运行时，而且会被类型检查器忽略。在运行时直接调用 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 装饰的函数会触发 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。下面的重载示例给出了比联合类型或类型变量更精准的类型：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>详见 <span class="target" id="index-234"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>，与其他类型语义进行对比。</p>
</dd></dl>

<dl class="py function">
<dt id="typing.final">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">final</code><a class="headerlink" href="#typing.final" title="永久链接至目标">¶</a></dt>
<dd><p>告知类型检查器被装饰的方法不能被覆盖，且被装饰的类不能作为子类的装饰器，例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>这些属性没有运行时检查。详见 <span class="target" id="index-235"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="typing.no_type_check">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="永久链接至目标">¶</a></dt>
<dd><p>标明注解不是类型提示的装饰器。</p>
<p>用作类或函数的 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a>。用于类时，递归地应用于该类中定义的所有方法，（但不影响超类或子类中定义的方法）。</p>
<p>本方法可直接修改函数。</p>
</dd></dl>

<dl class="py function">
<dt id="typing.no_type_check_decorator">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="永久链接至目标">¶</a></dt>
<dd><p>让其他装饰器具有 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 效果的装饰器。</p>
<p>本装饰器用 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 里的装饰函数打包其他装饰器。</p>
</dd></dl>

<dl class="py function">
<dt id="typing.type_check_only">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">type_check_only</code><a class="headerlink" href="#typing.type_check_only" title="永久链接至目标">¶</a></dt>
<dd><p>标记类或函数内不可用于运行时的装饰器。</p>
<p>在运行时，该装饰器本身不可用。实现返回的是私有类实例时，它主要是用于标记在类型存根文件中定义的类。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>注意，建议不要返回私有类实例，最好将之设为公共类。</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>内省辅助器<a class="headerlink" href="#introspection-helpers" title="永久链接至标题">¶</a></h3>
<dl class="py function">
<dt id="typing.get_type_hints">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_type_hints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">globalns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">localns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">include_extras</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="永久链接至目标">¶</a></dt>
<dd><p>返回函数、方法、模块、类对象的类型提示的字典。</p>
<p>一般情况下，与 <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code> 相同。此外，可通过在 <code class="docutils literal notranslate"><span class="pre">globals</span></code> 与 <code class="docutils literal notranslate"><span class="pre">locals</span></code> 命名空间里进行评估，以此来处理编码为字符串字面量的前向引用。如有需要，在默认值设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 时，可为函数或方法注解添加 <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code>。对于类 <code class="docutils literal notranslate"><span class="pre">C</span></code>，则返回由所有 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 与 <code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code> 逆序合并而成的字典。</p>
<p>本函数以递归地方式用 <code class="docutils literal notranslate"><span class="pre">T</span></code> 替换所有 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code>， 除非将 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 的值设置为 <code class="docutils literal notranslate"><span class="pre">True</span></code> （详见 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a>）。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>

<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> 在导入的 <a class="reference internal" href="#type-aliases"><span class="std std-ref">类型别名</span></a> 中不工作，包括前向引用。启用注解的延迟评估（ <span class="target" id="index-236"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0563"><strong>PEP 563</strong></a> ）可能会消除对大多数前向引用的需要。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版更改: </span><span class="target" id="index-237"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a> 的组成部分，添加了 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 参数。</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="typing.get_args">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_args</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="永久链接至目标">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="typing.get_origin">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_origin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="永久链接至目标">¶</a></dt>
<dd><p>为泛型类型与特殊类型形式提供了基本的内省功能。</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 形式的类型对象，这些函数返回 <code class="docutils literal notranslate"><span class="pre">X</span></code> 与 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>。如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是内置对象或 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> class 的泛型别名， 会将其标准化为原始类。如果 <code class="docutils literal notranslate"><span class="pre">X</span></code> 是包含在其他泛型类型中的联合类型或 <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a>，<code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> 的顺序会因类型缓存，而与原始参数 <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 的顺序不同。对于不支持的对象会相应地返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或 <code class="docutils literal notranslate"><span class="pre">()</span></code>。例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.8 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="typing.is_typeddict">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">is_typeddict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_typeddict" title="永久链接至目标">¶</a></dt>
<dd><p>检查一个类型是否为 <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>。</p>
<p>例如：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>  <span class="c1"># =&gt; True</span>
<span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># =&gt; False</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.10 新版功能.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="typing.ForwardRef">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ForwardRef</code><a class="headerlink" href="#typing.ForwardRef" title="永久链接至目标">¶</a></dt>
<dd><p>用于字符串前向引用的内部类型表示的类。 例如，<code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> 会被隐式转换为 <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>。 这个类不应由用户来实例化，但可以由内省工具使用。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><span class="target" id="index-238"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 泛型类型例如 <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code> 将不会被隐式地转换为 <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> 因而将不会自动解析为 <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.7.4 新版功能.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>常量<a class="headerlink" href="#constant" title="永久链接至标题">¶</a></h3>
<dl class="py data">
<dt id="typing.TYPE_CHECKING">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="永久链接至目标">¶</a></dt>
<dd><p>被第三方静态类型检查器假定为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 的特殊常量。 在运行时为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 用法如下:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>第一个类型注解必须用引号标注，才能把它当作“前向引用”，从而在解释器运行时中隐藏 <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> 引用。局部变量的类型注释不会被评估，因此，第二个注解不需要用引号引起来。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> 时，函数定义时不处理注解， 而是把注解当作字符串存在 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 里，这样就不必为注解使用引号。（详见 <span class="target" id="index-239"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0563"><strong>PEP 563</strong></a>）。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">3.5.2 新版功能.</span></p>
</div>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 类型注解支持</a><ul>
<li><a class="reference internal" href="#relevant-peps">相关的 PEP</a></li>
<li><a class="reference internal" href="#type-aliases">类型别名</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">可调对象（Callable）</a></li>
<li><a class="reference internal" href="#generics">泛型（Generic）</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">用户定义的泛型类型</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 类型</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">名义子类型 vs 结构子类型</a></li>
<li><a class="reference internal" href="#module-contents">模块内容</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">特殊类型原语</a><ul>
<li><a class="reference internal" href="#special-types">特殊类型</a></li>
<li><a class="reference internal" href="#special-forms">特殊形式</a></li>
<li><a class="reference internal" href="#building-generic-types">构建泛型类型</a></li>
<li><a class="reference internal" href="#other-special-directives">其他特殊指令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">泛型具象容器</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">对应的内置类型</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code> 对应类型</a></li>
<li><a class="reference internal" href="#other-concrete-types">其他具象类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">抽象基类</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 对应的容器</a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code> 对应的其他类型</a></li>
<li><a class="reference internal" href="#asynchronous-programming">异步编程</a></li>
<li><a class="reference internal" href="#context-manager-types">上下文管理器类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">协议</a></li>
<li><a class="reference internal" href="#functions-and-decorators">函数与装饰器</a></li>
<li><a class="reference internal" href="#introspection-helpers">内省辅助器</a></li>
<li><a class="reference internal" href="#constant">常量</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="development.html"
                        title="上一章">开发工具</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="pydoc.html"
                        title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> --- 文档生成器和在线帮助系统</a></p>
  <div role="note" aria-label="source link">
    <h3>当前页面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/typing.rst"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc --- 文档生成器和在线帮助系统"
             >下一页</a> |</li>
        <li class="right" >
          <a href="development.html" title="开发工具"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.5 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >开发工具</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> —— 类型注解支持</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 7月 24, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>