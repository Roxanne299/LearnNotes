# 1.2 基本概念

**导航：[6. Vue3](../6.Vue3)**

---



* `router`就是网址对应的页面 通过将 `router `中的` createWebHashHistory` 改成`createWebHistory `就可以去掉`url`中的`#`
* `components`和`views`一般都可以存组件
* 整个的入口就是在`main.js`，根组件`App`名称也是随便定义的 。新建一个根组件，将`router`和`store`(`vuex`)引入根组件，将整个`App`挂载到`app`元素上。`app`元素在`public`中的`index.html`中。
* 在前端页面 所有的`js`都会打包成一个整个的`js`
* `vue`是一个前端渲染框架。后端渲染模型一般就是前端按按钮，后端返回对应的一整个页面回前端。但前端渲染模型就是只有在第一次打开页面的时候，向服务器发送请求，服务器会将所有页面返回到一个`js`文件中。第二次打开页面的时候就会在前端渲染该页面，不会再次向服务器发送请求。

---

* 在`router`中的`index.js`可以看见定义的每一个页面都有一个`component` `vue`页面。每一个`.vue`文件都会有三个部分组成。第一部分`<template>`也就是`html`部分，第二部分就是`<script>`也就是`js`部分，第三个部分就是`<style>`也就是`css`部分。`vue`同一个页面里面会包含所有东西。`css <style>`标签中可以加一个`scope`属性，这样不同组件之间的选择器不会相互影响。使用了`scope`属性之后，会在选择器后面加一个随机值，这样该选择器就不会影响其他组件的选择器了。
* 在`vue`中，是由不同组件组成的，每一个页面可以分成不同的组件，比如导航栏可以是一个单独的组件，那么导航栏就会拥有单独的`html js css`。通过组件标签在`vue`引入组件。
* 如果定义的公共`vue`组件需要插入内容，可以使用`slot`标签表示插入在此处。
  * 因为如果使用`a`标签跳转页面那么其实还是每次点击从后端接收数据，那就是后端渲染不是前端渲染。可以使用`router-link`标签来代替`a`标签，其中`a`标签的`href`属性由`:to`代替。其中`:to`的值需要接一个对象`:to={name:'home'}`对象内的`name`就是路由每个页面设置的`name`属性。如果需要加参数的话那么就`:to = {name:'home',params:{uszerid:userid}}`


---

每一个`vue`都会导出一个`export default`对象

**script部分**
`export default`对象的属性：

* `name`：组件的名称
* `components`：存储`<template>`中用到的所有组件
* `props`：存储父组件传递给子组件的数据
* `watch()`：当某个数据发生变化时触发
* `computed`：动态计算某个数据

```vue
<script>
import {computed} from 'vue'; 
export default {
  name: "UserProfileInfo",
  props:{
      user:{
          type: Object,
          required: true,
      },
  },/*因为setup里面用不了this所以需要将props传入进去*/
  setup(props){
      let fullName = computed(()=>props.user.firstname + ' ' + props.user.lastname);
      
      return{
          fullname,
      }
  },
};
</script>
```

* `setup(props, context)`：初始化变量、函数
  * `ref`定义变量，可以用`.value`属性重新赋值，可以接受普通变量类型,使用的时候需要引入`import ref from  "vue";`,`ref`的读取和修改都需要`.value`来取的                                                                                                                                                                                                                                                                                                                                                   
  * `reactive`定义对象，不可重新赋值，运行效率高于`ref`，只能接受对象，使用的时候需要引入`import reactive from  "vue";`

```vue
/*父组件*/
<template>
  <Content>
    <div class="row">
      <div class="col-3"><UserProfileInfo @follow="follow" @unfollow="unfollow" :user="user"/></div>
      <div class="col-9"><UserProfilePosts /></div>
    </div>
  </Content>
</template>
  
  <script>
// @ is an alias to /src
import Content from "../components/Content.vue";
import UserProfileInfo from "../components/UserProfileInfo.vue";
import UserProfilePosts from "../components/UserProfilePosts.vue";
import reactive from  "vue";
export default {
  name: "UserProfileView",
  components: {
    Content,
    UserProfileInfo,
    UserProfilePosts,
  },
  setup(){
      const user = reactive({
          username: "Zhang Geyang",
          firstName: "Zhang",
          lastName: "Geyang",
          followed: false,
          follower_count: 2333,
      });
      
      const follow = ()=>{
          
      }
      
      const unfollow = ()=>{
          
      }
      
      return{
          follow,
          unfollow,
          user,
      }
            
  }
};
</script>
```

* `props`存储父组件传递过来的数据(父组件给子组件传递信息通过`props`，子组件给父组件船体信息通过触发事件)

```vue
/*父组件*/
<div class="col-3">
    <UserProfileInfo :user="user"/>
</div>
/*子组件*/
<template>
  <div class="card">
        <div class="col-9">
          <div class="username">{{user.username}}</div>
          <div class="fans">粉丝数量：{{user.follower_count}}</div>
          <button type="button" class="btn btn-light">+关注</button>
        </div>
</template>
<script>
export default {
  name: "UserProfileInfo",
  props:{
      user:{
          type: Object,
          requeired: true,
      },
  }
};
</script>

```

* `context.emit()`：触发父组件绑定的函数，父组件通过`@name="..."`来绑定函数，子组件可以通过`context.emit("name")`触发父组件绑定的函数。同时如果子组件需要传参给父组件，只需要`comtext.emit("function_name",params)`，父组件绑定事件不用加参数，直接正常绑定就好

```vue
/*父组件*/
<template>
  <Content>
    <div class="row">
      <div class="col-3"><UserProfileInfo @follow="follow" @unfollow="unfollow" :user="user"/></div>
      <div class="col-9"><UserProfilePosts /></div>
    </div>
  </Content>
</template>
  
<script>
// @ is an alias to /src
import Content from "../components/Content.vue";
import UserProfileInfo from "../components/UserProfileInfo.vue";
import UserProfilePosts from "../components/UserProfilePosts.vue";
import reactive from  "vue";
export default {
  name: "UserProfileView",
  components: {
    Content,
    UserProfileInfo,
    UserProfilePosts,
  },
  setup(){
      const user = reactive({
          username: "Zhang Geyang",
          firstName: "Zhang",
          lastName: "Geyang",
          followed: false,
          follower_count: 2333,
      });
      
      const follow = ()=>{
          if(user.followed) return;
          follower_count++;
          followed = true;
      }
      
      const unfollow = ()=>{
          if(!user.followed) return;
          follower_count--;
          followed = false;
      }
      
      return{
          follow,
          unfollow,
          user,
      }
            
  }
};
</script>
/*子组件*/
<template>
  <div class="card">
        <div class="col-9">
          <div class="username">{{user.username}}</div>
          <div class="fans">粉丝数量：{{user.follower_count}}</div>
          <button @click="follow" v-if="!user.followed" type="button" class="btn btn-light">+关注</button>
          <button @click="unfollow" v-if="user.followed" type="button" class="btn btn-light">取消关注</button>
        </div>
</template>
<script>
export default {
  name: "UserProfileInfo",
  props:{
      user:{
          type: Object,
          requeired: true,
      },
  },
  setup(props，context){
      let fullName = computed(()=>props.user.firstname + ' ' + props.user.lastname);
      
      const follow = ()=>{context.emit("follow")}；
      const unfollow = ()=>{context.emit("unfollow")}
      return{
          fullname,
          follow,
          unfollow,
      }
  }
};
</script>
```

---

**template部分**

* `<slot></slot>`：存放父组件传过来的`children`。
* `v-on:click`或`@click`属性：绑定事件`v-on:`可以被`@`代替，如果是表单提交的话是在`form`标签上添加`@submit="function"`。`@submit.prevent="function"`河上面一样只不过就是组织了表单提交的默认动作。

```vue
<template>
  <div class="card">
        <div class="col-9">
          <div class="username">{{user.username}}</div>
          <div class="fans">粉丝数量：{{user.follower_count}}</div>
          <button @click="follow" v-if="!user.followed" type="button" class="btn btn-light">+关注</button>
          <button @click="unfollow" v-if="user.followed" type="button" class="btn btn-light">取消关注</button>
        </div>
</template>
<script>
export default {
  name: "UserProfileInfo",
  props:{
      user:{
          type: Object,
          requeired: true,
      },
  },
  setup(props){
      let fullName = computed(()=>props.user.firstname + ' ' + props.user.lastname);
      
      const follow = ()=>{console.log("关注")}；
      const unfollow = ()=>{console.log("取消关注")}
      return{
          fullname,
          follow,
          unfollow,
      }
  }
};
</script>
```



* `v-if`、`v-else`、`v-else-if`属性：判断(当成立的时候标签显示，不成立的时候标签隐藏)

```vue
<button v-if="!user.followed" type="button" class="btn btn-light">+关注</button>
```

* `v-fo`r属性：循环，:`key`循环的每个元素需要有唯一的`key`
* `v-bind`:或`:`：绑定属性 如果属性后面不是普通字符串而是属性的话可以加一个`:`

```vue
<img :src="user.photo">
```



* `v-model:"name"`：将内容和`name`绑定起来

---

**style部分**

* `<style>`标签添加`scope`属性后，不同组件间的css不会相互影响

---

**第三方组件**

* `view-router`包：实现路由功能。
* `vuex`：存储全局状态，全局唯一。在`store=>index.js`中
  * `state`: 存储所有数据，可以用`modules`属性划分成若干模块，比如存储`users`
  * `getters`：根据`state`中的值计算新的值，比如需要计算`firstname + lastname`
  * `mutations`：所有对`state`的修改操作都需要定义在这里，不支持异步，可以通过`$store.commit()`触发
  * `actions`：定义对`state`的复杂修改操作，支持异步，可以通过`$store.dispatch()`触发。注意不能直接修改`state`，只能通过`mutations`修改`state`(`context.commit("function_in_mutation",{...resp})`)`...`作用就是解构，将对象内容解构成以逗号隔开的样子。

```javascript
setup() {
    let username = ref("");
    let password = ref("");
    const store = useStore();
    /*
    其中通过dispatch函数调用store中action的操作，后面传入参数，以及成功和失败的回调函数
    */
    let login = () => {
      store.dispatch("login",{
        username:username.value,
        password:password.value,
        success(){
          console.log("success");
        },
        error(){
          console.log("error");
        }
      })
    };
    return {
      username,
      password,
      login,
    };
  }
```

* `modules`：定义`state`的子模块，就是实现以`index.js`的格式实现另外的`user.js`，再引入到`modules`里面

```javascript
/*user.js*/
const user = {
    state: {
        username: "",
        id: "",
        firstname: "",
        lastname: "",
    },getters: {

    },mutations: { 
 
    },actions: {

    },modules: {
        users:user,
    }
};

export default{
    user,
}
/*index.js*/
import { createStore } from 'vuex';
import user from 'user.js';
export default createStore({
    state: {

    }, getters: {

    }, mutations: {

    }, actions: {

    }, modules: {
        user: user,
    }
})
/*访问vuex中的内容*/
const store = createStore();
console.log(store.state.user.username);
```



---

1. 在根组件中引入`bootstrap`的时候会报错，显示`Module not found: Error: Can't resolve '@popperjs/core' in 'D:\desktop\learn\开发\java\java\项目\配置git环境和项目搭建\Vue\myspace\node_modules\bootstrap\dist\js'`需要在依赖中单独安装`@popperjs/core`

   ```js
   /*引入boostrap js css
   */
   import "bootstrap/dist/css/bootstrap.min.css";
   import "bootstrap/dist/js/bootstrap.min.js";
   ```

2. `bootstrap`中`container-fluid`中的`fluid`代表左边的更左，右边的更右，删掉就会稍微中间一点了

3. `bootstrap`中`container`实现响应式布局

   下表说明了每个容器的最大宽度与每个断点上的原始.container和.container流体的比较。

   你可以在我们的网格示例中查看并比较它们。

   |              | `Extra small <576px` | `Small ≥576px` | `Medium ≥768px` | `Large ≥992px` | `X-Large ≥1200px` | `XX-Large ≥1400px` |
   | ------------ | -------------------- | -------------- | --------------- | -------------- | ----------------- | ------------------ |
   | `.container` | 100%                 | 540`px`        | 720`px`         | 960`px`        | 1140`px`          | 1320`px`           |

4. 当访问路由中没有定义的页面的时候，可以将下面的路由定义在最后，使得没有命名过的全部跳转到404

```vue
{
	path:'/:catchAll(.*)',
	redirect:'/404',
}
```

4. 同样在路由设置里面的`path`中，如果需要传入的不是字符串是id，可以使用`path:'/profile/:userid'`
5. 那么如何在上面对应路径的跳转页面来获取访问路径里面的参数呢？如果在当前页面设置了访问参数，那么默认访问这个页面的跳转连接也需要加一个参数`       <router-link class="nav-link" :to="{ name: 'userprofile' params:{userid:2}}"`

```javascript
import useRoute from 'vue-router';

const route = useRoute();
console.log(route.params.userid);
```

6. 要注意，如果`vuex`是后来安装的话，store文件夹是需要自己安装的，并且需要在`main.js`应用store

```javascript
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
createApp(App).use(router).use(store).mount('#app')
```

7. 解包`jwt`返回的`access`获得的编码，并且从编码中间获取相应信息，需要使用解码器，需要`import jwt_decode from 'jwt-decode';`

```javascript
success(resp){
    const {access,refresh} = resp;/*解包*/
    const access_obj = jwt_decode(access);/*解码*/
}
```

8. 在`ajax`中需要`jwt`验证的话，只需要在`ajax`内添加一个（背过）

```javascript
headers:{
    'Authorization': 'Bearer ' + access，
}
```

9. 使用`router`跳转页面

```javascript
import router from '@/router/index'

router.push({name:userlist});
```

10. 在页面标签中访问`store`参数需要`$store.state.user.islogin`
10. 为什么刷新网页之后，就不是登录状态了
10. 如果是在`store`中调用`mutation`那就是`context.commit("functionName",{params})`，同样调用`action`那就是`dispatch`。在标签里面访问的话就是`$store.user.`。如果是在非`store`访问的话

```javascript
import {useStore} from "vuex";//最好用{}框起来 不然报错

const store = UseStore();
store.commit(。。。);
```

13. 在`router`中可以在路径里面设置一个`:name`来接受传入的参数，在别的页面添加的`params`就是这个参数.当然获取这个参数的时候可以使用`route.params.userId`，**需要注意的是这里不是`router`**，页面跳转是`router`，获取参数是`route`，

```javascript
import router from '@/router/index'//router 不加{} 不然会跳转不过去

router.push({name:userlist,param:{userId:userId}});

import { useRoute } from 'vue-router';//要用大括号 不然报错
const route = useRoute();
const userId = route.params.userId;
```

14. 在好友列表点进去的好友简介的时候，点击自己是跳转不到自己的简介的，因为自己的界面和别人的界面是一样的，并没比较`userId`。需要在`app.vue`中的`router-view`标签中加上`:key="$route.fullPath"`，表示用完整路径来判重。（因为判重的时候数字部分被看成`router`里面定义的`:userId`比较了）
14. 同事件绑定函数不一样，事件绑定函数要传参的话，需要在绑定的地方加入参数，但是子组件事件绑定传父组件的话不用
14. `vue`中的`@`表示的是根目录，其实就是`src`目录
14. 在`APP.vue`中添加背景或者`css`，`style`标签如果加了`scoped`那就会不显示，然后加入背景
14. `card`不居中问题：在`content card`组件中添加父元素`div`，类名为`container`
14. 如何获取当前页面并且设置高亮

**第一种**

```vue
/*script部分使用useRoute获取当前页面的值 其实就是我们router里面index.js里面定义的每一个页面的值 需要computed实时计算*/
<script>
import { computed } from 'vue';
import { useRoute } from 'vue-router';

export default {
  name: "NavBar",
  setup(){
    const route = new useRoute();
    let routeName = computed(()=>{return route.name;});

    return{
        routeName
    }
  },
};
</script>

/*bar页面也就是导航部分 其实就是使用一个三元运算符*/

<router-link :class="routeName == 'pk_index' ? 'nav-link active' : 'nav-link'" :to="{ name: 'pk_index' }" >对战</router-link>
```

**第二种**

```html
/*导航栏加 active 样式，其实可以直接让 class="nav-link"；
然后加一个 active-class="active" 就可以实现了。
也就是最终写的是*/
<router-link class="nav-link" active-class="active" :to="{ name: 'pk_index' }"> 匹配对战</router-link>
```

20. `requestAnimationFrame()`里面传入一个函数。作用就是在下一帧浏览器页面刷新之前调用这个函数。如何实现这个动画的一直运动呢，使用递归

```js
const step = ()=>{
    //执行逻辑
    requestAnimationFrame(step);
}

requestAnimationFrame(step);
```

21. 代码脚本一般都放在`access`目录下面的`scripts`。所有的游戏对象都会继承一个基类`AcGameObject.js`

```js
//存放所有的游戏对象
const AC_GAME_OBJECTS = [];

export class AcGameObject {
    constructor(){
        //在游戏对象列表中加入当前对象
        AC_GAME_OBJECTS.push(this);
        //下面存放的就是对象的属性
        //记录是否执行过
        this.has_called_start = false;
        //记录这一帧到上一帧的时间间隔 对应速度
        this.timedelta = 0;
    }
    start(){//只执行一次 第一帧执行}
    update(){// 每一帧执行一次，第一帧除外 }
    on_destroy(){//删除之前还行 }
    destroy(){
        this.on_destroy();
        //删除调用这个函数的对象，其实就是删除自己
        for(let i in AC_GAME_OBJECTS){
            const obj = AC_GAME_OBJECTS[i];
            if(obj===this){
                AC_GAME_OBJECTS.splice(i);
                break;
            }
        }
    }
}

//实现动画的一直执行
let last_timestamp; //上一次执行的时刻
const step = (timestamp)=>{
    for(let obj in AC_GAME_OBJECTS){
        //如果没有执行过
        if(!obj.has_called_start){
            obj.has_called_start = true;
            obj.start();
        }else{//执行过的话
            obj.timedelta = timestamp - last_timestamp;
            obj.update();
        }
    }
    last_timestamp = timestamp;
    requestAnimationFrame(step);
}
requestAnimationFrame(step);
```

21. 游戏中的每一个组件都是一个`class`
22. 在`js`中`import `如果需要用`{}`说明是`export `出来的，反之就是`export default`出来的。需要注意的是`export default`在一个文件中只能用一次。
23. 一个有趣的方式是使用视口单位`vw`来实现响应式排版。`1vw`等同于视口宽度的百分之一，即如果你用`vw`来设定字体大小的话，字体的大小将总是随视口的大小进行改变。`vh`同理。
24. **`vue3`中`ref`的使用**：在 `Vue3` 的组合 `API` 中，采取了新的方案来执行对应的 `ref `标签属性获取。过去我们采用的是 `this.$refs` 的方案，现在，要首先创建 `ref `对象，然后再将这个` ref `对象创建出来，以实现监听。首先我们创建了一个 `parent`,`canvas` 的监听对象，然后将这个监听对象暴露出去，从而实现 `setup` 函数中和 节点 的绑定。但由于 `setup` 函数的执行时间要先于 `html` 标签的渲染，所以我们不能直接在 `setup` 函数中初始化标签。如果存在有初始化或类似的操作，需要借用 生命周期函数，而在 `setup` 中，要寻找生命周期需要用到 `on+`生命周期 的 `api`。通常来说，使用的会是 `onMounted`。

```vue
<template>
  <div ref="parent" class="gamemap"><canvas ref="canvas"> </canvas></div>
</template>
<script>
import {GameMap} from "@/assets/scripts/GameMap";
import {ref,onMounted}from "vue";
export default {
  name: "GameMap",
  setup(){
     
    let parent = ref(null);
    let canvas = ref(null);
     // 由于 template 中的 div 属性 ref 引用了一个对象 parent，因此 parent 将与这个 div 执行绑定。
    // 但由于 setup 执行时期，还未创建实际的 div，所以如果要进行与 parent 的交互，必须在生命周期中间执行获取。
    // onMounted() 中的行为会在声明周期 mounted 中执行。
    onMounted(()=>{
        new GameMap(canvas.value.getContext('2d'),parent.value)
    });
    return{
        parent,
        canvas
    }
  },
};
</script>

<style scoped>
.gamemap {
  /*同父元素等长宽*/
  width: 100%;
  height: 100%;
}
</style>
```

25. `canvas`的使用：`Document.getElementById() `方法获取 HTML` <canvas> `元素的引用。接`HTMLCanvasElement.getContext()` 方法获取这个元素的 `context`——图像稍后将在此被渲染。在`vue`中就是使用`ref`来获取。

26. `Element.clientWidth`可以获取指定元素的宽高，同样这个指定元素对象可以通过`ref`获得。

27. 如何实现变量的深度复制`const g = Json.parse(Json.stringify(g));`

28. 如何使用`router`实现前端的用户鉴权（没有登录状态点击标签跳转登录页面，登陆之后再跳转之前想要访问的页面）

    ```javascript
    //为了记录每隔页面是不是要登录状态才可以进入 可以在router index.js中定义额外的信息 meta{ requestAuth:true,}每次判断一下就好了
    //------router- index.js-----------
    //每次跳转页面之前会检查一下
    router.beforeEach((to,from,next)=>{
      if(to.meta.requestAuth && !store.state.user.is_login && to.name !== 'user_account_login'){
        console.log(1);
        next({name: "user_account_login"});
      }else{
        //跳转到本来要的页面
        next();
      }
    })
    
    router.beforeEach((to,from,next)=>{
    //to表示将要跳转到哪里 from 表示从哪个页面来 next是下一步跳转的地方
    
    })
    ```

29. `js`文件使用`store`使用` import store from ‘@/store/index’`，但是`vue`使用`store`就是用` import { useStore } from ‘vuex’, const store = useStore(),`

30. 使用`router.beforeEach`报错`[Vue Router warn]: Detected an infinite redirection in a navigation guard when going from "/" to "/user/account/login/". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`。这个报错的意思就是，当我们需要访问`login`页面的时候他就会判断再进去`login`，导致无限循环，所以我们需要判断一下当前访问页面是不是`login`页面。

    ```javascript
    //原本代码
    //每次跳转页面之前会检查一下
    router.beforeEach((to,from,next)=>{
      if(to.meta.requestAuth && !store.state.user.is_login ){
        console.log(1);
        next({name: "user_account_login"});
      }else{
        //跳转到本来要的页面
        next();
      }
    })
    
    
    
    //不报错代码
    //每次跳转页面之前会检查一下
    router.beforeEach((to,from,next)=>{
      if(to.meta.requestAuth && !store.state.user.is_login && to.name !== 'user_account_login'){
        console.log(1);
        next({name: "user_account_login"});
      }else{
        //跳转到本来要的页面
        next();
      }
    })
    ```

31. 如何实现数据的持久化，也就是我们的登录信息都是存在了`js`也就是本地的内存里面，如果一刷新，`js`也会刷新，实现数据的持久化我们就需要把数据存到`localstorage`里面

    ```javascript
    //1. 登录成功之后将token存入LocalStorage
    //--------------------------------vue-x store--------------------------------------
     login(context,data){
                $.ajax({
                    url: "http://127.0.0.1:8081/user/account/token/",
                    type: "post",
                    data: {
                        username: data.username,
                        password: data.password,
                    },
                    success(resp){
                        if(resp.error_message == "success"){
                            //登录成功之后将token存入LocalStorage
                            localStorage.setItem("token",resp.token);
                            context.commit("updateToken",resp.token);
                            data.success(resp);
                        }
                    },
                    error(){
                        data.error();
                    }
                });
            },
    ```

    ```javascript
    <!--因为每次刷新都会跳转到登录页面，所以在登录页面判断对应的token是否存在 首先获取token 然后然获取对应的用户信息 获取成功就跳转到首页不然就跳转到登录页面 -->    
    //content_show 用于使用v-if写入标签 防止跳转到登录页面之后再跳转到首页会有一个白色的登录页面闪过
    //注意 logout之后也要删掉LocalStorage 并且 加上跳转到登录页面
    //其实可以使用一个全局变量来维护 这样页面上闪过的画面都可以优化
    let token = localStorage.getItem("token");
        let content_show = ref(false);
    
        if (token == null) {
          console.log(content_show.value);
          content_show.value = true;
        } else {
          //更新全局信息token
          store.commit("updateToken", token);
          store.dispatch("getInfo", {
            success() {
              content_show.value = false;
              //验证成功跳转到首页
              router.push({ name: "pk_index" });
            },
            error() {
              content_show.value = true;
              localStorage.removeItem("token");
            },
          });
        }
    ```
    
32. 实现浮窗效果，`bootstrap`搜索`modal`  

    ```html
    <!-- Button trigger modal -->
    <!-- 其中这个按钮绑定Modal 是通过 Modal的id和button的data-bs-target绑定的-->    
    <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#staticBackdrop">
      Launch static backdrop modal
    </button>
    
    <!-- Modal -->
    <div class="modal fade" id="staticBackdrop" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1" aria-labelledby="staticBackdropLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="staticBackdropLabel">Modal title</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            ...
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary">Understood</button>
          </div>
        </div>
      </div>
    </div>
    
    ```
    
    如果需要实现`Modal`的关闭，那就需要如下函数
    
    ```javascript
    import {Modal} from "bootstrap/dist/js/bootstrap"
    
    //通过Modal 的 id来获取对象调用hide函数来实现隐藏
    Modal.getInstance("#idName").hide();
    ```
    
33. 在实现了`32`的隐藏浮窗效果之后，主页的下拉框失效了，但是把`import {Modal} from "bootstrap/dist/js/bootstrap"`这句话注释掉就重新生效，改成`import "bootstrap/dist/js/bootstrap.min.js";`就可以。我猜测是引入了不一样的`js`导致的错误。**要注意在循环里面生成的`Modal`需要加一个唯一标识，不然会导致每次都调用的是第一个`Modal`**

33. 后端生成时间是正确的时区 但是在前端就不一样了，在`pojo`中对应的变量`JsonFormat`注释中加上`,timezone = "Asia/Shanghai"`
